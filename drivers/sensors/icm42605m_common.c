/*
 * TDK icm42605m driver
 *
 * Copyright 2020 TDK Inc.
 * Licensed under the GPL-2.
 */

#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/errno.h>
#include <linux/types.h>
#include <linux/mutex.h>
#include <linux/interrupt.h>
#include <linux/i2c.h>
#include <linux/gpio.h>
#include <linux/delay.h>
#include <linux/of.h>
#include <linux/irq.h>
#include <linux/fs.h>
#include <linux/uaccess.h>
#include <asm/unaligned.h>
#include <linux/hrtimer.h>
#include <linux/input.h>
#include <linux/workqueue.h>
#include <linux/regulator/consumer.h>
#include <linux/of_gpio.h>
#include <linux/pinctrl/consumer.h>
#include "../pinctrl/core.h"


#include "icm42605m_common.h"

/* ----------------------------------------------------------------------------
 * Device Register map
 *
 * Next macros defines address for all icm426xx registers as listed by device
 * datasheet.
 * Macros name is MPUREG_<REGISTER_NAME> with REGISTER_NAME being the name of
 * the corresponding register in datasheet.
 * Note that macro name is MPUREG_<REGISTER_NAME>_Bx with x being the bank
 * number for registers that are in bank 1 and 2 (suffix is ommitted for
 * bank0 registers)
 * ---------------------------------------------------------------------------- */

/* Bank 0 */
#define MPUREG_CHIP_CONFIG        0x11
#define MPUREG_DRIVE_CONFIG       0x13
#define MPUREG_INT_CONFIG         0x14
#define MPUREG_FIFO_CONFIG        0x16
#define MPUREG_TEMP_DATA0_UI      0x1D
#define MPUREG_ACCEL_DATA_X0_UI   0x1F
#define MPUREG_GYRO_DATA_X0_UI    0x25
#define MPUREG_TMST_FSYNC1        0x2B
#define MPUREG_INT_STATUS         0x2D
#define MPUREG_FIFO_BYTE_COUNT1   0x2E
#define MPUREG_FIFO_BYTE_COUNT2   0x2F
#define MPUREG_FIFO_DATA          0x30
#define MPUREG_APEX_DATA0         0x31
#define MPUREG_APEX_DATA1         0x32
#define MPUREG_APEX_DATA2         0x33
#define MPUREG_APEX_DATA3         0x34
#define MPUREG_APEX_DATA4         0x35
#define MPUREG_APEX_DATA5         0x36
#define MPUREG_INT_STATUS2        0x37
#define MPUREG_INT_STATUS3        0x38
#define MPUREG_SIGNAL_PATH_RESET  0x4B
#define MPUREG_INTF_CONFIG0       0x4C
#define MPUREG_INTF_CONFIG1       0x4D
#define MPUREG_PWR_MGMT_0         0x4E
#define MPUREG_GYRO_CONFIG0       0x4F
#define MPUREG_ACCEL_CONFIG0      0x50
#define MPUREG_GYRO_CONFIG1       0x51
#define MPUREG_ACCEL_GYRO_CONFIG0 0x52
#define MPUREG_ACCEL_CONFIG1      0x53
#define MPUREG_TMST_CONFIG        0x54
#define MPUREG_APEX_CONFIG0       0x56
#define MPUREG_SMD_CONFIG         0x57
#define MPUREG_INT_RAW            0x58
#define MPUREG_FIFO_CONFIG1       0x5F
#define MPUREG_FIFO_CONFIG2       0x60
#define MPUREG_FSYNC_CONFIG       0x62
#define MPUREG_INT_CONFIG0        0x63
#define MPUREG_INT_CONFIG1        0x64
#define MPUREG_INT_SOURCE0        0x65
#define MPUREG_INT_SOURCE1        0x66
#define MPUREG_INT_SOURCE2        0x67
#define MPUREG_INT_SOURCE3        0x68
#define MPUREG_INT_SOURCE4        0x69
#define MPUREG_INT_SOURCE5        0x6A
#define MPUREG_SENSOR_SELFTEST    0x6B
#define MPUREG_FIFO_LOST_PKT0     0x6C
#define MPUREG_SELF_TEST_CONFIG   0x70
#define MPUREG_SCAN0              0x71
#define MPUREG_MEM_BANK_SEL       0x72
#define MPUREG_MEM_START_ADDR     0x73
#define MPUREG_MEM_R_W            0x74
#define MPUREG_WHO_AM_I           0x75
#define MPUREG_REG_BANK_SEL       0x76

/* Bank 1 */
#define MPUREG_GYRO_CONFIG_STATIC2_B1 0x0B
#define MPUREG_GYRO_CONFIG_STATIC3_B1 0x0C
#define MPUREG_GYRO_CONFIG_STATIC4_B1 0x0D
#define MPUREG_GYRO_CONFIG_STATIC5_B1 0x0E
#define MPUREG_XG_ST_DATA_B1          0x5F
#define MPUREG_YG_ST_DATA_B1          0x60
#define MPUREG_ZG_ST_DATA_B1          0x61
#define MPUREG_TMST_VAL0_B1           0x62
#define MPUREG_OTP_SEC_STATUS_B1      0x70
#define MPUREG_HTR_CONFIG_B1          0x77
#define MPUREG_INTF_CONFIG4_B1        0x7A
#define MPUREG_INTF_CONFIG5_B1        0x7B
#define MPUREG_INTF_CONFIG6_B1        0x7C

/* Bank 2 */
#define MPUREG_ACCEL_CONFIG_STATIC2_B2 0x03
#define MPUREG_ACCEL_CONFIG_STATIC3_B2 0x04
#define MPUREG_ACCEL_CONFIG_STATIC4_B2 0x05
#define MPUREG_ACCEL_CONFIG_STATIC0_B2 0x39
#define MPUREG_XA_ST_DATA_B2           0x3B
#define MPUREG_YA_ST_DATA_B2           0x3C
#define MPUREG_ZA_ST_DATA_B2           0x3D
/* Only accessible from AUX1 */
#define MPUREG_OIS1_CONFIG1_B2         0x44
#define MPUREG_OIS1_CONFIG2_B2         0x45
#define MPUREG_OIS1_CONFIG3_B2         0x46
#define MPUREG_ACCEL_DATA_X0_OIS1_B2   0x49
#define MPUREG_GYRO_DATA_X0_OIS1_B2    0x4F
#define MPUREG_INT_STATUS_OIS1_B2      0x57
/* End of Only accessible from AUX1 */
/* Only accessible from AUX2 */
#define MPUREG_OIS2_CONFIG1_B2         0x59
#define MPUREG_OIS2_CONFIG2_B2         0x5A
#define MPUREG_OIS2_CONFIG3_B2         0x5B
#define MPUREG_ACCEL_DATA_X0_OIS2_B2   0x5E
#define MPUREG_GYRO_DATA_X0_OIS2_B2    0x64
#define MPUREG_INT_STATUS_OIS2_B2      0x6C
/* End of Only accessible from AUX2 */

/* Bank 4 */
#define MPUREG_APEX_CONFIG1_B4    0x40
#define MPUREG_APEX_CONFIG2_B4    0x41
#define MPUREG_APEX_CONFIG3_B4    0x42
#define MPUREG_APEX_CONFIG4_B4    0x43
#define MPUREG_APEX_CONFIG5_B4    0x44
#define MPUREG_APEX_CONFIG6_B4    0x45
#define MPUREG_APEX_CONFIG7_B4    0x46
#define MPUREG_APEX_CONFIG8_B4    0x47
#define MPUREG_APEX_CONFIG9_B4    0x48
#define MPUREG_ACCEL_WOM_X_THR_B4 0x4A
#define MPUREG_ACCEL_WOM_Y_THR_B4 0x4B
#define MPUREG_ACCEL_WOM_Z_THR_B4 0x4C
#define MPUREG_INT_SOURCE6_B4     0x4D
#define MPUREG_INT_SOURCE7_B4     0x4E
#define MPUREG_INT_SOURCE8_B4     0x4F
#define MPUREG_INT_SOURCE9_B4     0x50
#define MPUREG_INT_SOURCE10_B4    0x51
#define MPUREG_INTF_CONFIG10_B4   0x52
#define MPUREG_OFFSET_USER_0_B4   0x77
#define MPUREG_OFFSET_USER_1_B4   0x78
#define MPUREG_OFFSET_USER_2_B4   0x79
#define MPUREG_OFFSET_USER_3_B4   0x7A
#define MPUREG_OFFSET_USER_4_B4   0x7B
#define MPUREG_OFFSET_USER_5_B4   0x7C
#define MPUREG_OFFSET_USER_6_B4   0x7D
#define MPUREG_OFFSET_USER_7_B4   0x7E
#define MPUREG_OFFSET_USER_8_B4   0x7F

#define ICM42605_WHOAMI 0x42

/* GYRO_MODE */
#define BIT_PWR_MGMT_0_GYRO_MODE_POS        2
#define BIT_PWR_MGMT_0_GYRO_MODE_MASK   (0x03 << BIT_PWR_MGMT_0_GYRO_MODE_POS)

typedef enum
{
	ICM426XX_PWR_MGMT_0_GYRO_MODE_LN      =
		(0x03 << BIT_PWR_MGMT_0_GYRO_MODE_POS),
	ICM426XX_PWR_MGMT_0_GYRO_MODE_STANDBY =
		(0x01 << BIT_PWR_MGMT_0_GYRO_MODE_POS),
	ICM426XX_PWR_MGMT_0_GYRO_MODE_OFF     =
		(0x00 << BIT_PWR_MGMT_0_GYRO_MODE_POS),
} ICM426XX_PWR_MGMT_0_GYRO_MODE_t;

/* ACCEL_MODE */
#define BIT_PWR_MGMT_0_ACCEL_MODE_POS       0
#define BIT_PWR_MGMT_0_ACCEL_MODE_MASK   0x03

typedef enum
{
	ICM426XX_PWR_MGMT_0_ACCEL_MODE_LN  = 0x03,
	ICM426XX_PWR_MGMT_0_ACCEL_MODE_LP  = 0x02,
	ICM426XX_PWR_MGMT_0_ACCEL_MODE_OFF = 0x00,
} ICM426XX_PWR_MGMT_0_ACCEL_MODE_t;

/* SMD_MODE */
#define BIT_SMD_CONFIG_SMD_MODE_POS       0
#define BIT_SMD_CONFIG_SMD_MODE_MASK    0x3

typedef enum
{
	ICM426XX_SMD_CONFIG_SMD_MODE_LONG     = 0x03,
	ICM426XX_SMD_CONFIG_SMD_MODE_SHORT    = 0x02,
	ICM426XX_SMD_CONFIG_SMD_MODE_WOM      = 0x01,
	ICM426XX_SMD_CONFIG_SMD_MODE_DISABLED = 0x00,
} ICM426XX_SMD_CONFIG_SMD_MODE_t;

/* TILT_EN */
#define BIT_APEX_CONFIG0_TILT_EN_POS       4
#define BIT_APEX_CONFIG0_TILT_EN_MASK   (0x1 << BIT_APEX_CONFIG0_TILT_EN_POS)

 typedef enum
{
	ICM426XX_APEX_CONFIG0_TILT_EN_EN   = (0x1 << BIT_APEX_CONFIG0_TILT_EN_POS),
	ICM426XX_APEX_CONFIG0_TILT_EN_DIS  = (0x0 << BIT_APEX_CONFIG0_TILT_EN_POS),
} ICM426XX_APEX_CONFIG0_TILT_EN_t;

/* DMP_INIT_EN */
#define BIT_SIGNAL_PATH_RESET_DMP_INIT_POS   6
#define BIT_SIGNAL_PATH_RESET_DMP_INIT_MASK  \
	(0x01 << BIT_SIGNAL_PATH_RESET_DMP_INIT_POS)

typedef enum
{
	ICM426XX_SIGNAL_PATH_RESET_DMP_INIT_EN  =
		(0x01 << BIT_SIGNAL_PATH_RESET_DMP_INIT_POS),
	ICM426XX_SIGNAL_PATH_RESET_DMP_INIT_DIS =
		(0x00 << BIT_SIGNAL_PATH_RESET_DMP_INIT_POS),
} ICM426XX_SIGNAL_PATH_RESET_DMP_INIT_t;

/* DMP_IDLE */
#define BIT_APEX_DATA3_DMP_IDLE_POS        2
#define BIT_APEX_DATA3_DMP_IDLE_MASK   (0x01 << BIT_APEX_DATA3_DMP_IDLE_POS)

typedef enum
{
	ICM426XX_APEX_DATA3_DMP_IDLE_ON     =
		(0x01 << BIT_APEX_DATA3_DMP_IDLE_POS),
	ICM426XX_APEX_DATA3_DMP_IDLE_OFF    =
		(0x00 << BIT_APEX_DATA3_DMP_IDLE_POS),
} ICM426XX_APEX_DATA3_DMP_IDLE_OFF_t;

/* DMP_MEM_RESET_EN */
#define BIT_SIGNAL_PATH_RESET_DMP_MEM_RESET_POS   \
	5
#define BIT_SIGNAL_PATH_RESET_DMP_MEM_RESET_MASK  \
	(0x01 << BIT_SIGNAL_PATH_RESET_DMP_MEM_RESET_POS)

typedef enum
{
	ICM426XX_SIGNAL_PATH_RESET_DMP_MEM_RESET_EN  =
		(0x01 << BIT_SIGNAL_PATH_RESET_DMP_MEM_RESET_POS),
	ICM426XX_SIGNAL_PATH_RESET_DMP_MEM_RESET_DIS =
		(0x00 << BIT_SIGNAL_PATH_RESET_DMP_MEM_RESET_POS),
} ICM426XX_SIGNAL_PATH_RESET_DMP_MEM_RESET_t;

/** @brief Configure Fifo usage
 */
typedef enum {
	INV_ICM426XX_FIFO_DISABLED = 0,              /**< Fifo is disabled and data source is sensors registers */
	INV_ICM426XX_FIFO_ENABLED  = 1,              /**< Fifo is used as data source */
}INV_ICM426XX_FIFO_CONFIG_t;

/* FIFO_MODE */
#define BIT_FIFO_CONFIG_MODE_POS        6
#define BIT_FIFO_CONFIG_MODE_MASK   (0x03 << BIT_FIFO_CONFIG_MODE_POS)

typedef enum
{
	ICM426XX_FIFO_CONFIG_MODE_SNAPSHOT  = (0x02 << BIT_FIFO_CONFIG_MODE_POS),
	ICM426XX_FIFO_CONFIG_MODE_STREAM    = (0x01 << BIT_FIFO_CONFIG_MODE_POS),
	ICM426XX_FIFO_CONFIG_MODE_BYPASS    = (0x00 << BIT_FIFO_CONFIG_MODE_POS),
} ICM426XX_FIFO_CONFIG_MODE_t;

/* FIFO_COUNT_REC */
#define BIT_FIFO_COUNT_REC_POS               6
#define BIT_FIFO_COUNT_REC_MASK          (0x01 << BIT_FIFO_COUNT_REC_POS)

typedef enum
{
	ICM426XX_INTF_CONFIG0_FIFO_COUNT_REC_RECORD = (0x01 << BIT_FIFO_COUNT_REC_POS),
	ICM426XX_INTF_CONFIG0_FIFO_COUNT_REC_BYTE   = (0x00 << BIT_FIFO_COUNT_REC_POS),
} ICM426XX_INTF_CONFIG0_FIFO_COUNT_REC_t;

/* FIFO_COUNT_ENDIAN */
#define BIT_FIFO_COUNT_ENDIAN_POS           5
#define BIT_FIFO_COUNT_ENDIAN_MASK      (0x01 << BIT_FIFO_COUNT_ENDIAN_POS)

typedef enum
{
	ICM426XX_INTF_CONFIG0_FIFO_COUNT_BIG_ENDIAN    = (0x01 << BIT_FIFO_COUNT_ENDIAN_POS),
	ICM426XX_INTF_CONFIG0_FIFO_COUNT_LITTLE_ENDIAN = (0x00 << BIT_FIFO_COUNT_ENDIAN_POS),
} ICM426XX_INTF_CONFIG0_FIFO_COUNT_ENDIAN_t;

/* FIFO_TEMP_EN */
#define BIT_FIFO_CONFIG1_TEMP_POS       2
#define BIT_FIFO_CONFIG1_TEMP_MASK   (0x1 << BIT_FIFO_CONFIG1_TEMP_POS)

typedef enum
{
	ICM426XX_FIFO_CONFIG1_TEMP_EN  = (0x1 << BIT_FIFO_CONFIG1_TEMP_POS),
	ICM426XX_FIFO_CONFIG1_TEMP_DIS = (0x0 << BIT_FIFO_CONFIG1_TEMP_POS),
} ICM426XX_FIFO_CONFIG1_TEMP_t;

/* FIFO_GYRO_EN */
#define BIT_FIFO_CONFIG1_GYRO_POS       1
#define BIT_FIFO_CONFIG1_GYRO_MASK   (0x1 << BIT_FIFO_CONFIG1_GYRO_POS)

typedef enum
{
	ICM426XX_FIFO_CONFIG1_GYRO_EN  = (0x1 << BIT_FIFO_CONFIG1_GYRO_POS),
	ICM426XX_FIFO_CONFIG1_GYRO_DIS = (0x0 << BIT_FIFO_CONFIG1_GYRO_POS),
} ICM426XX_FIFO_CONFIG1_GYRO_t;

/* FIFO_ACCEL_EN*/
#define BIT_FIFO_CONFIG1_ACCEL_POS       0
#define BIT_FIFO_CONFIG1_ACCEL_MASK    0x1

typedef enum
{
	ICM426XX_FIFO_CONFIG1_ACCEL_EN  = 0x01,
	ICM426XX_FIFO_CONFIG1_ACCEL_DIS = 0x00,
} ICM426XX_FIFO_CONFIG1_ACCEL_t;

/* FIFO_TMST_FSYNC_EN */
#define BIT_FIFO_CONFIG1_TMST_FSYNC_POS       3
#define BIT_FIFO_CONFIG1_TMST_FSYNC_MASK   (0x1 << BIT_FIFO_CONFIG1_TMST_FSYNC_POS)

typedef enum
{
	ICM426XX_FIFO_CONFIG1_TMST_FSYNC_EN  = (0x1 << BIT_FIFO_CONFIG1_TMST_FSYNC_POS),
	ICM426XX_FIFO_CONFIG1_TMST_FSYNC_DIS = (0x0 << BIT_FIFO_CONFIG1_TMST_FSYNC_POS),
} ICM426XX_FIFO_CONFIG1_TMST_FSYNC_t;

/* FIFO_FLUSH */
#define BIT_SIGNAL_PATH_RESET_FIFO_FLUSH_POS        1
#define BIT_SIGNAL_PATH_RESET_FIFO_FLUSH_MASK   (0x01 << BIT_SIGNAL_PATH_RESET_FIFO_FLUSH_POS)

typedef enum
{
	ICM426XX_SIGNAL_PATH_RESET_FIFO_FLUSH_EN  = (0x01 << BIT_SIGNAL_PATH_RESET_FIFO_FLUSH_POS),
	ICM426XX_SIGNAL_PATH_RESET_FIFO_FLUSH_DIS = (0x00 << BIT_SIGNAL_PATH_RESET_FIFO_FLUSH_POS),
} ICM426XX_SIGNAL_PATH_RESET_FIFO_FLUSH_t;

/* ACCEL_UI_FILT_BW_IND */
#define BIT_GYRO_ACCEL_CONFIG0_ACCEL_FILT_POS    4
#define BIT_GYRO_ACCEL_CONFIG0_ACCEL_FILT_MASK   \
	(0xF << BIT_GYRO_ACCEL_CONFIG0_ACCEL_FILT_POS)

typedef enum
{
	ICM426XX_GYRO_ACCEL_CONFIG0_ACCEL_FILT_BW_40 =
		(0x7 << BIT_GYRO_ACCEL_CONFIG0_ACCEL_FILT_POS),
	ICM426XX_GYRO_ACCEL_CONFIG0_ACCEL_FILT_BW_20 =
		(0x6 << BIT_GYRO_ACCEL_CONFIG0_ACCEL_FILT_POS),
	ICM426XX_GYRO_ACCEL_CONFIG0_ACCEL_FILT_BW_16 =
		(0x5 << BIT_GYRO_ACCEL_CONFIG0_ACCEL_FILT_POS),
	ICM426XX_GYRO_ACCEL_CONFIG0_ACCEL_FILT_BW_10 =
		(0x4 << BIT_GYRO_ACCEL_CONFIG0_ACCEL_FILT_POS),
	ICM426XX_GYRO_ACCEL_CONFIG0_ACCEL_FILT_BW_8  =
		(0x3 << BIT_GYRO_ACCEL_CONFIG0_ACCEL_FILT_POS),
	ICM426XX_GYRO_ACCEL_CONFIG0_ACCEL_FILT_BW_5  =
		(0x2 << BIT_GYRO_ACCEL_CONFIG0_ACCEL_FILT_POS),
	ICM426XX_GYRO_ACCEL_CONFIG0_ACCEL_FILT_BW_4  =
		(0x1 << BIT_GYRO_ACCEL_CONFIG0_ACCEL_FILT_POS),
	ICM426XX_GYRO_ACCEL_CONFIG0_ACCEL_FILT_BW_2  =
		(0x0 << BIT_GYRO_ACCEL_CONFIG0_ACCEL_FILT_POS),
} ICM426XX_GYRO_ACCEL_CONFIG0_ACCEL_FILT_BW_t;

typedef enum
{
	ICM426XX_GYRO_ACCEL_CONFIG0_ACCEL_FILT_AVG_16  =
		(0x6 << BIT_GYRO_ACCEL_CONFIG0_ACCEL_FILT_POS),
	ICM426XX_GYRO_ACCEL_CONFIG0_ACCEL_FILT_AVG_1   =
		(0x1 << BIT_GYRO_ACCEL_CONFIG0_ACCEL_FILT_POS),
} ICM426XX_GYRO_ACCEL_CONFIG0_ACCEL_FILT_AVG_t;

/* GYRO_UI_FILT_BW_IND */
#define BIT_GYRO_ACCEL_CONFIG0_GYRO_FILT_POS       0
#define BIT_GYRO_ACCEL_CONFIG0_GYRO_FILT_MASK   0x0F

typedef enum
{
	ICM426XX_GYRO_ACCEL_CONFIG0_GYRO_FILT_BW_40 = 0x07,
	ICM426XX_GYRO_ACCEL_CONFIG0_GYRO_FILT_BW_20 = 0x06,
	ICM426XX_GYRO_ACCEL_CONFIG0_GYRO_FILT_BW_16 = 0x05,
	ICM426XX_GYRO_ACCEL_CONFIG0_GYRO_FILT_BW_10 = 0x04,
	ICM426XX_GYRO_ACCEL_CONFIG0_GYRO_FILT_BW_8  = 0x03,
	ICM426XX_GYRO_ACCEL_CONFIG0_GYRO_FILT_BW_5  = 0x02,
	ICM426XX_GYRO_ACCEL_CONFIG0_GYRO_FILT_BW_4  = 0x01,
	ICM426XX_GYRO_ACCEL_CONFIG0_GYRO_FILT_BW_2  = 0x00,
} ICM426XX_GYRO_ACCEL_CONFIG0_GYRO_FILT_BW_t;

/** @brief Contains the current register values.
	Used to reapply values after the ST procedure
 */
struct recover_regs {
	/* bank 0 */
	u8 intf_config0;       /* REG_INTF_CONFIG0       */
	u8 intf_config1;       /* REG_INTF_CONFIG1       */
	u8 pwr_mgmt_0;         /* REG_PWR_MGMT_0         */
	u8 accel_config0;      /* REG_ACCEL_CONFIG0      */
	u8 accel_config1;      /* REG_ACCEL_CONFIG1      */
	u8 gyro_config0;       /* REG_GYRO_CONFIG0       */
	u8 gyro_config1;       /* REG_GYRO_CONFIG1       */
	u8 accel_gyro_config0; /* REG_ACCEL_GYRO_CONFIG0 */
	u8 fifo_config;        /* REG_FIFO_CONFIG       */
	u8 fifo_config1;       /* REG_FIFO_CONFIG1       */
	u8 self_test_config;   /* REG_SELF_TEST_CONFIG   */
};

/*
 * MPUREG_INT_STATUS
 * Register Name: INT_STATUS
 */
#define BIT_INT_STATUS_UI_FSYNC   0x40
#define BIT_INT_STATUS_PLL_RDY    0x20
#define BIT_INT_STATUS_RESET_DONE 0x10
#define BIT_INT_STATUS_DRDY       0x08
#define BIT_INT_STATUS_FIFO_THS   0x04
#define BIT_INT_STATUS_FIFO_FULL  0x02
#define BIT_INT_STATUS_AGC_RDY    0x01

/*
 * MPUREG_INT_STATUS2
 * Register Name: INT_STATUS2
 */
#define BIT_INT_STATUS2_SMD_INT        0x08
#define BIT_INT_STATUS2_WOM_Z_INT      0x04
#define BIT_INT_STATUS2_WOM_Y_INT      0x02
#define BIT_INT_STATUS2_WOM_X_INT      0x01

/*
 * MPUREG_INT_STATUS3
 * Register Name: INT_STATUS3
 */
#define BIT_INT_STATUS3_STEP_DET        0x20
#define BIT_INT_STATUS3_STEP_CNT_OVFL   0x10
#define BIT_INT_STATUS3_TILT_DET        0x08
#define BIT_INT_STATUS3_WAKE_DET        0x04
#define BIT_INT_STATUS3_LOW_G_DET       0x04
#define BIT_INT_STATUS3_SLEEP_DET       0x02
#define BIT_INT_STATUS3_HIGH_G_DET      0x02
#define BIT_INT_STATUS3_TAP_DET         0x01


/* GYRO_UI_FILT_ORD */
#define BIT_GYRO_CONFIG1_GYRO_UI_FILT_ORD_POS    2
#define BIT_GYRO_CONFIG1_GYRO_UI_FILT_ORD_MASK   \
	(0x3 << BIT_GYRO_CONFIG1_GYRO_UI_FILT_ORD_POS)

typedef enum
{
	ICM426XX_GYRO_CONFIG_GYRO_UI_FILT_ORD_1ST_ORDER =
		(0x0 << BIT_GYRO_CONFIG1_GYRO_UI_FILT_ORD_POS),
	ICM426XX_GYRO_CONFIG_GYRO_UI_FILT_ORD_2ND_ORDER =
		(0x1 << BIT_GYRO_CONFIG1_GYRO_UI_FILT_ORD_POS),
	ICM426XX_GYRO_CONFIG_GYRO_UI_FILT_ORD_3RD_ORDER =
		(0x2 << BIT_GYRO_CONFIG1_GYRO_UI_FILT_ORD_POS),
} ICM426XX_GYRO_CONFIG_GYRO_UI_FILT_ORD_t;

/* GYRO_DEC2_M2_ORD */
#define BIT_GYRO_CONFIG1_GYRO_DEC2_M2_ORD_POS      0
#define BIT_GYRO_CONFIG1_GYRO_DEC2_M2_ORD_MASK   0x3

/** register configuration for self-test procedure */
#define DEFAULT_ST_GYRO_DEC2_M2_ORD      2
#define DEFAULT_ST_GYRO_UI_FILT_ORD_IND  \
	ICM426XX_GYRO_CONFIG_GYRO_UI_FILT_ORD_3RD_ORDER
#define DEFAULT_ST_GYRO_UI_FILT_BW_IND   \
	ICM426XX_GYRO_ACCEL_CONFIG0_GYRO_FILT_BW_10

#define DEFAULT_ST_ACCEL_UI_FILT_ORD_IND \
	ICM426XX_ACCEL_CONFIG_ACCEL_UI_FILT_ORD_3RD_ORDER
#define DEFAULT_ST_ACCEL_UI_FILT_BW_IND  \
	ICM426XX_GYRO_ACCEL_CONFIG0_ACCEL_FILT_BW_10

/* GYRO_FS_SEL*/
#define BIT_GYRO_CONFIG0_FS_SEL_POS      5
#define BIT_GYRO_CONFIG0_FS_SEL_MASK     \
	(7 << BIT_GYRO_CONFIG0_FS_SEL_POS)

/** @brief Gyroscope FSR selection
 */
typedef enum
{
#if defined(ICM42686)
	ICM426XX_GYRO_CONFIG0_FS_SEL_31dps   =
		(7 << BIT_GYRO_CONFIG0_FS_SEL_POS),  /*!< 31dps*/
	ICM426XX_GYRO_CONFIG0_FS_SEL_62dps   =
		(6 << BIT_GYRO_CONFIG0_FS_SEL_POS),  /*!< 62dps*/
	ICM426XX_GYRO_CONFIG0_FS_SEL_125dps  =
		(5 << BIT_GYRO_CONFIG0_FS_SEL_POS),  /*!< 125dps*/
	ICM426XX_GYRO_CONFIG0_FS_SEL_250dps  =
		(4 << BIT_GYRO_CONFIG0_FS_SEL_POS),  /*!< 250dps*/
	ICM426XX_GYRO_CONFIG0_FS_SEL_500dps  =
		(3 << BIT_GYRO_CONFIG0_FS_SEL_POS),  /*!< 500dps*/
	ICM426XX_GYRO_CONFIG0_FS_SEL_1000dps =
		(2 << BIT_GYRO_CONFIG0_FS_SEL_POS),  /*!< 1000dps*/
	ICM426XX_GYRO_CONFIG0_FS_SEL_2000dps =
		(1 << BIT_GYRO_CONFIG0_FS_SEL_POS),  /*!< 2000dps*/
	ICM426XX_GYRO_CONFIG0_FS_SEL_4000dps =
		(0 << BIT_GYRO_CONFIG0_FS_SEL_POS),  /*!< 4000dps*/
#else
	ICM426XX_GYRO_CONFIG0_FS_SEL_16dps   =
		(7 << BIT_GYRO_CONFIG0_FS_SEL_POS),  /*!< 16dps*/
	ICM426XX_GYRO_CONFIG0_FS_SEL_31dps   =
		(6 << BIT_GYRO_CONFIG0_FS_SEL_POS),  /*!< 31dps*/
	ICM426XX_GYRO_CONFIG0_FS_SEL_62dps   =
		(5 << BIT_GYRO_CONFIG0_FS_SEL_POS),  /*!< 62dps*/
	ICM426XX_GYRO_CONFIG0_FS_SEL_125dps  =
		(4 << BIT_GYRO_CONFIG0_FS_SEL_POS),  /*!< 125dps*/
	ICM426XX_GYRO_CONFIG0_FS_SEL_250dps  =
		(3 << BIT_GYRO_CONFIG0_FS_SEL_POS),  /*!< 250dps*/
	ICM426XX_GYRO_CONFIG0_FS_SEL_500dps  =
		(2 << BIT_GYRO_CONFIG0_FS_SEL_POS),  /*!< 500dps*/
	ICM426XX_GYRO_CONFIG0_FS_SEL_1000dps =
		(1 << BIT_GYRO_CONFIG0_FS_SEL_POS),  /*!< 1000dps*/
	ICM426XX_GYRO_CONFIG0_FS_SEL_2000dps =
		(0 << BIT_GYRO_CONFIG0_FS_SEL_POS),  /*!< 2000dps*/
#endif
} ICM426XX_GYRO_CONFIG0_FS_SEL_t;

/* GYRO_ODR */
#define BIT_GYRO_CONFIG0_ODR_POS       0
#define BIT_GYRO_CONFIG0_ODR_MASK   0x0F

/** @brief Gyroscope ODR selection
 */
typedef enum
{
	ICM426XX_GYRO_CONFIG0_ODR_500_HZ    = 0x0F,  /*!< 500 Hz (2 ms)*/
	ICM426XX_GYRO_CONFIG0_ODR_12_5_HZ   = 0x0B,  /*!< 12.5 Hz (80 ms)*/
	ICM426XX_GYRO_CONFIG0_ODR_25_HZ     = 0x0A,  /*!< 25 Hz (40 ms)*/
	ICM426XX_GYRO_CONFIG0_ODR_50_HZ     = 0x09,  /*!< 50 Hz (20 ms)*/
	ICM426XX_GYRO_CONFIG0_ODR_100_HZ    = 0x08,  /*!< 100 Hz (10 ms)*/
	ICM426XX_GYRO_CONFIG0_ODR_200_HZ    = 0x07,  /*!< 200 Hz (5 ms)*/
	ICM426XX_GYRO_CONFIG0_ODR_1_KHZ     = 0x06,  /*!< 1 KHz (1 ms)*/
	ICM426XX_GYRO_CONFIG0_ODR_2_KHZ     = 0x05,  /*!< 2 KHz (500 us)*/
	ICM426XX_GYRO_CONFIG0_ODR_4_KHZ     = 0x04,  /*!< 4 KHz (250 us)*/
	ICM426XX_GYRO_CONFIG0_ODR_8_KHZ     = 0x03,  /*!< 8 KHz (125 us)*/
	ICM426XX_GYRO_CONFIG0_ODR_16_KHZ    = 0x02,  /*!< 16 KHz (62.5 us)*/
	ICM426XX_GYRO_CONFIG0_ODR_32_KHZ    = 0x01,  /*!< 32 KHz (31.25 us)*/
} ICM426XX_GYRO_CONFIG0_ODR_t;

/* ACCEL_UI_FILT_ORD */
#define BIT_ACCEL_CONFIG1_ACCEL_UI_FILT_ORD_POS     3
#define BIT_ACCEL_CONFIG1_ACCEL_UI_FILT_ORD_MASK    \
	(0x3 << BIT_ACCEL_CONFIG1_ACCEL_UI_FILT_ORD_POS)

typedef enum
{
	ICM426XX_ACCEL_CONFIG_ACCEL_UI_FILT_ORD_1ST_ORDER =
		(0x0 << BIT_ACCEL_CONFIG1_ACCEL_UI_FILT_ORD_POS),
	ICM426XX_ACCEL_CONFIG_ACCEL_UI_FILT_ORD_2ND_ORDER =
		(0x1 << BIT_ACCEL_CONFIG1_ACCEL_UI_FILT_ORD_POS),
	ICM426XX_ACCEL_CONFIG_ACCEL_UI_FILT_ORD_3RD_ORDER =
		(0x2 << BIT_ACCEL_CONFIG1_ACCEL_UI_FILT_ORD_POS),
} ICM426XX_ACCEL_CONFIG_ACCEL_UI_FILT_ORD_t;

/* ACCEL_FS_SEL */
#define BIT_ACCEL_CONFIG0_FS_SEL_POS    5
#define BIT_ACCEL_CONFIG0_FS_SEL_MASK   \
	(0x7 << BIT_ACCEL_CONFIG0_FS_SEL_POS)

/** @brief Accelerometer FSR selection
 */
typedef enum
{
#if defined(ICM42686)
	ICM426XX_ACCEL_CONFIG0_FS_SEL_2g  =
		(0x4 << BIT_ACCEL_CONFIG0_FS_SEL_POS),  /*!< 2g*/
	ICM426XX_ACCEL_CONFIG0_FS_SEL_4g  =
		(0x3 << BIT_ACCEL_CONFIG0_FS_SEL_POS),  /*!< 4g*/
	ICM426XX_ACCEL_CONFIG0_FS_SEL_8g  =
		(0x2 << BIT_ACCEL_CONFIG0_FS_SEL_POS),  /*!< 8g*/
	ICM426XX_ACCEL_CONFIG0_FS_SEL_16g =
		(0x1 << BIT_ACCEL_CONFIG0_FS_SEL_POS),  /*!< 16g*/
	ICM426XX_ACCEL_CONFIG0_FS_SEL_32g =
		(0x0 << BIT_ACCEL_CONFIG0_FS_SEL_POS),  /*!< 32g*/
#else
	ICM426XX_ACCEL_CONFIG0_FS_SEL_RESERVED =
		(0x4 << BIT_ACCEL_CONFIG0_FS_SEL_POS),
	ICM426XX_ACCEL_CONFIG0_FS_SEL_2g       =
		(0x3 << BIT_ACCEL_CONFIG0_FS_SEL_POS),  /*!< 2g*/
	ICM426XX_ACCEL_CONFIG0_FS_SEL_4g       =
		(0x2 << BIT_ACCEL_CONFIG0_FS_SEL_POS),  /*!< 4g*/
	ICM426XX_ACCEL_CONFIG0_FS_SEL_8g       =
		(0x1 << BIT_ACCEL_CONFIG0_FS_SEL_POS),  /*!< 8g*/
	ICM426XX_ACCEL_CONFIG0_FS_SEL_16g      =
		(0x0 << BIT_ACCEL_CONFIG0_FS_SEL_POS),  /*!< 16g*/
#endif
} ICM426XX_ACCEL_CONFIG0_FS_SEL_t;

/* ACCEL_ODR */
#define BIT_ACCEL_CONFIG0_ODR_POS       0
#define BIT_ACCEL_CONFIG0_ODR_MASK   0x0F

/** @brief Accelerometer ODR selection
 */
typedef enum
{
	ICM426XX_ACCEL_CONFIG0_ODR_500_HZ    = 0xF,  /*!< 500 Hz (2 ms)*/
	ICM426XX_ACCEL_CONFIG0_ODR_1_5625_HZ = 0xE,  /*!< 1.5625 Hz (640 ms)*/
	ICM426XX_ACCEL_CONFIG0_ODR_3_125_HZ  = 0xD,  /*!< 3.125 Hz (320 ms)*/
	ICM426XX_ACCEL_CONFIG0_ODR_6_25_HZ   = 0xC,  /*!< 6.25 Hz (160 ms)*/
	ICM426XX_ACCEL_CONFIG0_ODR_12_5_HZ   = 0xB,  /*!< 12.5 Hz (80 ms)*/
	ICM426XX_ACCEL_CONFIG0_ODR_25_HZ     = 0xA,  /*!< 25 Hz (40 ms)*/
	ICM426XX_ACCEL_CONFIG0_ODR_50_HZ     = 0x9,  /*!< 50 Hz (20 ms)*/
	ICM426XX_ACCEL_CONFIG0_ODR_100_HZ    = 0x8,  /*!< 100 Hz (10 ms)*/
	ICM426XX_ACCEL_CONFIG0_ODR_200_HZ    = 0x7,  /*!< 200 Hz (5 ms)*/
	ICM426XX_ACCEL_CONFIG0_ODR_1_KHZ     = 0x6,  /*!< 1 KHz (1 ms)*/
	ICM426XX_ACCEL_CONFIG0_ODR_2_KHZ     = 0x5,  /*!< 2 KHz (500 us)*/
	ICM426XX_ACCEL_CONFIG0_ODR_4_KHZ     = 0x4,  /*!< 4 KHz (250 us)*/
	ICM426XX_ACCEL_CONFIG0_ODR_8_KHZ     = 0x3,  /*!< 8 KHz (125 us)*/
	ICM426XX_ACCEL_CONFIG0_ODR_16_KHZ    = 0x2,  /*!< 16 KHz (62.5 us)*/
	ICM426XX_ACCEL_CONFIG0_ODR_32_KHZ    = 0x1,  /*!< 32 KHz (31.25 us)*/
} ICM426XX_ACCEL_CONFIG0_ODR_t;

/* SPI_AP_4WIRE */
#define BIT_INTF_CONFIG4_AP_SPI_POS       1
#define BIT_INTF_CONFIG4_AP_SPI_MASK   (0x1 << BIT_INTF_CONFIG4_AP_SPI_POS)

typedef enum
{
	ICM426XX_INTF_CONFIG4_AP_SPI4W = (0x1 << BIT_INTF_CONFIG4_AP_SPI_POS),
	ICM426XX_INTF_CONFIG4_AP_SPI3W = (0x0 << BIT_INTF_CONFIG4_AP_SPI_POS),
} ICM426XX_INTF_CONFIG4_AP_SPI_t;

/*
 * MPUREG_INT_CONFIG
 * Register Name: INT_CONFIG
 */

/* INT2_DRIVE_CIRCUIT */
#define BIT_INT_CONFIG_INT2_DRIVE_CIRCUIT_POS        4
#define BIT_INT_CONFIG_INT2_DRIVE_CIRCUIT_MASK   (0x01 << BIT_INT_CONFIG_INT2_DRIVE_CIRCUIT_POS)

typedef enum
{
	ICM426XX_INT_CONFIG_INT2_DRIVE_CIRCUIT_PP = (0x01 << BIT_INT_CONFIG_INT2_DRIVE_CIRCUIT_POS),
	ICM426XX_INT_CONFIG_INT2_DRIVE_CIRCUIT_OD = (0x00 << BIT_INT_CONFIG_INT2_DRIVE_CIRCUIT_POS),
} ICM426XX_INT_CONFIG_INT2_DRIVE_CIRCUIT_t;

/* INT2_POLARITY */
#define BIT_INT_CONFIG_INT2_POLARITY_POS        3
#define BIT_INT_CONFIG_INT2_POLARITY_MASK   (0x01 << BIT_INT_CONFIG_INT2_POLARITY_POS)

typedef enum
{
	ICM426XX_INT_CONFIG_INT2_POLARITY_HIGH = (0x01 << BIT_INT_CONFIG_INT2_POLARITY_POS),
	ICM426XX_INT_CONFIG_INT2_POLARITY_LOW  = (0x00 << BIT_INT_CONFIG_INT2_POLARITY_POS),
} ICM426XX_INT_CONFIG_INT2_POLARITY_t;

/* INT1_DRIVE_CIRCUIT */
#define BIT_INT_CONFIG_INT1_DRIVE_CIRCUIT_POS        1
#define BIT_INT_CONFIG_INT1_DRIVE_CIRCUIT_MASK   (0x01 << BIT_INT_CONFIG_INT1_DRIVE_CIRCUIT_POS)

typedef enum
{
	ICM426XX_INT_CONFIG_INT1_DRIVE_CIRCUIT_PP = (0x01 << BIT_INT_CONFIG_INT1_DRIVE_CIRCUIT_POS),
	ICM426XX_INT_CONFIG_INT1_DRIVE_CIRCUIT_OD = (0x00 << BIT_INT_CONFIG_INT1_DRIVE_CIRCUIT_POS),
} ICM426XX_INT_CONFIG_INT1_DRIVE_CIRCUIT_t;

/* INT1_POLARITY */
#define BIT_INT_CONFIG_INT1_POLARITY_POS       0
#define BIT_INT_CONFIG_INT1_POLARITY_MASK   0x01

typedef enum
{
	ICM426XX_INT_CONFIG_INT1_POLARITY_HIGH = 0x01,
	ICM426XX_INT_CONFIG_INT1_POLARITY_LOW  = 0x00,
} ICM426XX_INT_CONFIG_INT1_POLARITY_t;

/* INT1_INT_MODE */
#define BIT_INT_CONFIG_INT1_INT_MODE_POS    2
#define BIT_INT_CONFIG_INT1_INT_MODE_MASK   (0x01 << BIT_INT_CONFIG_INT1_INT_MODE_POS)

typedef enum
{
	ICM426XX_INT_CONFIG_INT1_INT_MODE_LATCHED = (0x01 << BIT_INT_CONFIG_INT1_INT_MODE_POS),
	ICM426XX_INT_CONFIG_INT1_INT_MODE_PULSED = (0x00 << BIT_INT_CONFIG_INT1_INT_MODE_POS),
} ICM426XX_INT_CONFIG_INT1_INT_MODE_t;

/* INT2_INT_MODE */
#define BIT_INT_CONFIG_INT2_INT_MODE_POS    5
#define BIT_INT_CONFIG_INT2_INT_MODE_MASK   (0x01 << BIT_INT_CONFIG_INT2_INT_MODE_POS)

typedef enum
{
	ICM426XX_INT_CONFIG_INT2_INT_MODE_LATCHED = (0x01 << BIT_INT_CONFIG_INT2_INT_MODE_POS),
	ICM426XX_INT_CONFIG_INT2_INT_MODE_PULSED = (0x00 << BIT_INT_CONFIG_INT2_INT_MODE_POS),
} ICM426XX_INT_CONFIG_INT2_INT_MODE_t;

/* Interrupt enum state for INT1, INT2, and IBI */
typedef enum{
	INV_ICM426XX_DISABLE = 0,
	INV_ICM426XX_ENABLE
}inv_icm426xx_interrupt_value;

typedef struct {
	inv_icm426xx_interrupt_value INV_ICM426XX_UI_FSYNC;
	inv_icm426xx_interrupt_value INV_ICM426XX_UI_DRDY;
	inv_icm426xx_interrupt_value INV_ICM426XX_FIFO_THS;
	inv_icm426xx_interrupt_value INV_ICM426XX_FIFO_FULL;
	inv_icm426xx_interrupt_value INV_ICM426XX_SMD;
	inv_icm426xx_interrupt_value INV_ICM426XX_WOM_X;
	inv_icm426xx_interrupt_value INV_ICM426XX_WOM_Y;
	inv_icm426xx_interrupt_value INV_ICM426XX_WOM_Z;
	inv_icm426xx_interrupt_value INV_ICM426XX_STEP_DET;
	inv_icm426xx_interrupt_value INV_ICM426XX_STEP_CNT_OVFL;
	inv_icm426xx_interrupt_value INV_ICM426XX_TILT_DET;
	inv_icm426xx_interrupt_value INV_ICM426XX_HIGHG_DET;
	inv_icm426xx_interrupt_value INV_ICM426XX_LOWG_DET;
	inv_icm426xx_interrupt_value INV_ICM426XX_TAP_DET;
}inv_icm426xx_interrupt_parameter_t;

/*
 * MPUREG_INT_SOURCE0
 * Register Name: INT_SOURCE0
 */
#define BIT_INT_UI_FSYNC_INT_EN_POS         6
#define BIT_INT_PLL_RDY_INT_EN_POS          5
#define BIT_INT_RESET_DONE_INT_EN_POS       4
#define BIT_INT_UI_DRDY_INT_EN_POS          3
#define BIT_INT_FIFO_THS_INT_EN_POS         2
#define BIT_INT_FIFO_FULL_INT_EN_POS        1
#define BIT_INT_UI_AGC_RDY_INT_EN_POS       0

#define BIT_INT_SOURCE0_UI_FSYNC_INT1_EN    0x40
#define BIT_INT_SOURCE0_PLL_RDY_INT1_EN     0x20
#define BIT_INT_SOURCE0_RESET_DONE_INT1_EN  0x10
#define BIT_INT_SOURCE0_UI_DRDY_INT1_EN     0x08
#define BIT_INT_SOURCE0_FIFO_THS_INT1_EN    0x04
#define BIT_INT_SOURCE0_FIFO_FULL_INT1_EN   0x02
#define BIT_INT_SOURCE0_UI_AGC_RDY_INT1_EN  0x01

/*
 * MPUREG_INT_SOURCE1
 * Register Name: INT_SOURCE1
 */
#define BIT_INT_SMD_INT_EN_POS              3
#define BIT_INT_WOM_Z_INT_EN_POS            2
#define BIT_INT_WOM_Y_INT_EN_POS            1
#define BIT_INT_WOM_X_INT_EN_POS            0

#define BIT_INT_SOURCE1_SMD_INT1_EN         0x08
#define BIT_INT_SOURCE1_WOM_Z_INT1_EN       0x04
#define BIT_INT_SOURCE1_WOM_Y_INT1_EN       0x02
#define BIT_INT_SOURCE1_WOM_X_INT1_EN       0x01

/*
 * MPUREG_INT_SOURCE2
 * Register Name: INT_SOURCE2
 */
#define BIT_INT_SOURCE2_OIS2_AGC_RDY_INT1_EN 0x20
#define BIT_INT_SOURCE2_OIS2_FSYNC_INT1_EN   0x10
#define BIT_INT_SOURCE2_OIS2_DRDY_INT1_EN    0x08
#define BIT_INT_SOURCE2_OIS1_AGC_RDY_INT1_EN 0x04
#define BIT_INT_SOURCE2_OIS1_FSYNC_INT1_EN   0x02
#define BIT_INT_SOURCE2_OIS1_DRDY_INT1_EN    0x01

/*
 * MPUREG_INT_SOURCE3
 * Register Name: INT_SOURCE3
 */
#define BIT_INT_SOURCE3_UI_FSYNC_INT2_EN    0x40
#define BIT_INT_SOURCE3_PLL_RDY_INT2_EN     0x20
#define BIT_INT_SOURCE3_RESET_DONE_INT2_EN  0x10
#define BIT_INT_SOURCE3_UI_DRDY_INT2_EN     0x08
#define BIT_INT_SOURCE3_FIFO_THS_INT2_EN    0x04
#define BIT_INT_SOURCE3_FIFO_FULL_INT2_EN   0x02
#define BIT_INT_SOURCE3_UI_AGC_RDY_INT2_EN  0x01

/*
 * MPUREG_INT_SOURCE4
 * Register Name: INT_SOURCE4
 */
#define BIT_INT_SOURCE4_SMD_INT2_EN         0x08
#define BIT_INT_SOURCE4_WOM_Z_INT2_EN       0x04
#define BIT_INT_SOURCE4_WOM_Y_INT2_EN       0x02
#define BIT_INT_SOURCE4_WOM_X_INT2_EN       0x01

/*
 * MPUREG_INT_SOURCE5
 * Register Name: INT_SOURCE5
 */
#define BIT_INT_SOURCE5_OIS2_AGC_RDY_INT2_EN 0x20
#define BIT_INT_SOURCE5_OIS2_FSYNC_INT2_EN   0x10
#define BIT_INT_SOURCE5_OIS2_DRDY_INT2_EN    0x08
#define BIT_INT_SOURCE5_OIS1_AGC_RDY_INT2_EN 0x04
#define BIT_INT_SOURCE5_OIS1_FSYNC_INT2_EN   0x02
#define BIT_INT_SOURCE5_OIS1_DRDY_INT2_EN    0x01

/*
 * MPUREG_INT_SOURCE6_B4
 * Register Name: INT_SOURCE6
 */
#define BIT_INT_STEP_DET_INT_EN_POS      5
#define BIT_INT_STEP_CNT_OVFL_INT_EN_POS 4
#define BIT_INT_TILT_DET_INT_EN_POS      3
#define BIT_INT_LOWG_DET_INT_EN_POS      2
#define BIT_INT_HIGHG_DET_INT_EN_POS     1
#define BIT_INT_TAP_DET_INT_EN_POS       0

#define BIT_INT_SOURCE6_STEP_DET_INT1_EN        0x20
#define BIT_INT_SOURCE6_STEP_CNT_OVFL_INT1_EN   0x10
#define BIT_INT_SOURCE6_TILT_DET_INT1_EN        0x8
#define BIT_INT_SOURCE6_LOWG_DET_INT1_EN        0x4
#define BIT_INT_SOURCE6_HIGHG_DET_INT1_EN       0x2
#define BIT_INT_SOURCE6_TAP_DET_INT1_EN         0x1

/*
 * MPUREG_INT_SOURCE7_B4
 * Register Name: INT_SOURCE7
 */
#define BIT_INT_SOURCE7_STEP_DET_INT2_EN        0x20
#define BIT_INT_SOURCE7_STEP_CNT_OVFL_INT2_EN   0x10
#define BIT_INT_SOURCE7_TILT_DET_INT2_EN        0x8
#define BIT_INT_SOURCE7_LOWG_DET_INT2_EN        0x4
#define BIT_INT_SOURCE7_HIGHG_DET_INT2_EN       0x2
#define BIT_INT_SOURCE7_TAP_DET_INT2_EN         0x1

/*
 * MPUREG_INT_SOURCE8_B4
 * Register Name: INT_SOURCE8
 */
#define BIT_INT_OIS1_DRDY_IBI_EN_POS  6
#define BIT_INT_UI_FSYNC_IBI_EN_POS   5
#define BIT_INT_PLL_RDY_IBI_EN_POS    4
#define BIT_INT_UI_DRDY_IBI_EN_POS    3
#define BIT_INT_FIFO_THS_IBI_EN_POS   2
#define BIT_INT_FIFO_FULL_IBI_EN_POS  1
#define BIT_INT_UI_AGC_RDY_IBI_EN_POS 0

#define BIT_INT_SOURCE8_OIS1_DRDY_IBI_EN  0x40
#define BIT_INT_SOURCE8_UI_FSYNC_IBI_EN   0x20
#define BIT_INT_SOURCE8_PLL_RDY_IBI_EN    0x10
#define BIT_INT_SOURCE8_UI_DRDY_IBI_EN    0x08
#define BIT_INT_SOURCE8_FIFO_THS_IBI_EN   0x04
#define BIT_INT_SOURCE8_FIFO_FULL_IBI_EN  0x02
#define BIT_INT_SOURCE8_UI_AGC_RDY_IBI_EN 0x01

/*
 * MPUREG_INT_SOURCE9_B4
 * Register Name: INT_SOURCE9
 */
#define BIT_INT_SMD_IBI_EN_POS                 4
#define BIT_INT_WOM_Z_IBI_EN_POS               3
#define BIT_INT_WOM_Y_IBI_EN_POS               2
#define BIT_INT_WOM_X_IBI_EN_POS               1

#define BIT_INT_SOURCE9_SMD_IBI_EN             0x10
#define BIT_INT_SOURCE9_WOM_Z_IBI_EN           0x08
#define BIT_INT_SOURCE9_WOM_Y_IBI_EN           0x04
#define BIT_INT_SOURCE9_WOM_X_IBI_EN           0x02

/*
 * MPUREG_INT_SOURCE10_B4
 * Register Name: INT_SOURCE10
 */
#define BIT_INT_STEP_DET_IBI_EN_POS      5
#define BIT_INT_STEP_CNT_OVFL_IBI_EN_POS 4
#define BIT_INT_TILT_DET_IBI_EN_POS      3
#define BIT_INT_LOWG_DET_IBI_EN_POS      2
#define BIT_INT_HIGHG_DET_IBI_EN_POS     1
#define BIT_INT_TAP_DET_IBI_EN_POS       0

#define BIT_INT_SOURCE10_STEP_DET_IBI_EN      0x20
#define BIT_INT_SOURCE10_STEP_CNT_OVFL_IBI_EN 0x10
#define BIT_INT_SOURCE10_TILT_DET_IBI_EN      0x08
#define BIT_INT_SOURCE10_LOWG_DET_IBI_EN      0x04
#define BIT_INT_SOURCE10_HIGHG_DET_IBI_EN     0x02
#define BIT_INT_SOURCE10_TAP_DET_IBI_EN       0x01

/* DMP_POWER_SAVE_EN */
#define BIT_APEX_CONFIG0_DMP_POWER_SAVE_POS       7
#define BIT_APEX_CONFIG0_DMP_POWER_SAVE_MASK   (0x1 << BIT_APEX_CONFIG0_DMP_POWER_SAVE_POS)

 typedef enum
{
	ICM426XX_APEX_CONFIG0_DMP_POWER_SAVE_EN   = (0x1 << BIT_APEX_CONFIG0_DMP_POWER_SAVE_POS),
	ICM426XX_APEX_CONFIG0_DMP_POWER_SAVE_DIS  = (0x0 << BIT_APEX_CONFIG0_DMP_POWER_SAVE_POS),
} ICM426XX_APEX_CONFIG0_DMP_POWER_SAVE_t;

/* DMP_ODR */
#define BIT_APEX_CONFIG0_DMP_ODR_POS       0
#define BIT_APEX_CONFIG0_DMP_ODR_MASK   (0x3 << BIT_APEX_CONFIG0_DMP_ODR_POS)

/** @brief DMP ODR selection
 */
typedef enum
{
	ICM426XX_APEX_CONFIG0_DMP_ODR_25Hz   = (0x0 << BIT_APEX_CONFIG0_DMP_ODR_POS), /**< 25Hz (40ms) */
	ICM426XX_APEX_CONFIG0_DMP_ODR_50Hz   = (0x2 << BIT_APEX_CONFIG0_DMP_ODR_POS), /**< 50Hz (20ms) */
	ICM426XX_APEX_CONFIG0_DMP_ODR_100Hz  = (0x3 << BIT_APEX_CONFIG0_DMP_ODR_POS), /**< 100Hz (10ms) */
} ICM426XX_APEX_CONFIG0_DMP_ODR_t;

/* TILT_WAIT_TIME_SEL */

#define BIT_APEX_CONFIG4_TILT_WAIT_TIME_POS   6
#define BIT_APEX_CONFIG4_TILT_WAIT_TIME_MASK (0x03<<BIT_APEX_CONFIG4_TILT_WAIT_TIME_POS)

typedef enum
{
	ICM426XX_APEX_CONFIG4_TILT_WAIT_TIME_0  = (0  << BIT_APEX_CONFIG4_TILT_WAIT_TIME_POS),
	ICM426XX_APEX_CONFIG4_TILT_WAIT_TIME_2S = (1  << BIT_APEX_CONFIG4_TILT_WAIT_TIME_POS),
	ICM426XX_APEX_CONFIG4_TILT_WAIT_TIME_4S = (2  << BIT_APEX_CONFIG4_TILT_WAIT_TIME_POS),
	ICM426XX_APEX_CONFIG4_TILT_WAIT_TIME_6S = (3  << BIT_APEX_CONFIG4_TILT_WAIT_TIME_POS)
} ICM426XX_APEX_CONFIG4_TILT_WAIT_TIME_t;

#define ICM_TILT_FREQUENCY_MODE                      ICM426XX_APEX_CONFIG0_DMP_ODR_50Hz

/* WOM threshold to be applied to ICM, ranges from 1 to 255 */
#define ICM_WOM_THRESHOLD    75

/* WOM_INT_MODE */
#define BIT_SMD_CONFIG_WOM_INT_MODE_POS       3
#define BIT_SMD_CONFIG_WOM_INT_MODE_MASK   (0x1 << BIT_SMD_CONFIG_WOM_INT_MODE_POS)

typedef enum
{
	ICM426XX_SMD_CONFIG_WOM_INT_MODE_ANDED = (0x01 << BIT_SMD_CONFIG_WOM_INT_MODE_POS),
	ICM426XX_SMD_CONFIG_WOM_INT_MODE_ORED  = (0x00 << BIT_SMD_CONFIG_WOM_INT_MODE_POS),
} ICM426XX_SMD_CONFIG_WOM_INT_MODE_t;

/* WOM_MODE */
#define BIT_SMD_CONFIG_WOM_MODE_POS       2
#define BIT_SMD_CONFIG_WOM_MODE_MASK   (0x1 << BIT_SMD_CONFIG_WOM_MODE_POS)

typedef enum
{
	ICM426XX_SMD_CONFIG_WOM_MODE_CMP_PREV = (0x01 << BIT_SMD_CONFIG_WOM_MODE_POS),
	ICM426XX_SMD_CONFIG_WOM_MODE_CMP_INIT = (0x00 << BIT_SMD_CONFIG_WOM_MODE_POS),
} ICM426XX_SMD_CONFIG_WOM_MODE_t;

/** @brief Icm426xx APEX inputs parameters definition
 */
typedef struct inv_icm426xx_apex_parameters {
	ICM426XX_APEX_CONFIG4_TILT_WAIT_TIME_t tilt_wait_time;             /**< Number of accelerometer samples to wait before triggering tilt event */
	ICM426XX_APEX_CONFIG0_DMP_POWER_SAVE_t power_save;                 /**< Power save mode for APEX algorithms. This mode will put APEX features into sleep mode,
	                                                                        leaving only the WOM running to wake-up the DMP */
} inv_icm426xx_apex_parameters_t;

/* SOFT_RESET_CHIP_CONFIG */
#define BIT_CHIP_CONFIG_RESET_POS       0
#define BIT_CHIP_CONFIG_RESET_MASK   0x01
typedef enum
{
	ICM426XX_CHIP_CONFIG_RESET_EN   = 0x01,
	ICM426XX_CHIP_CONFIG_RESET_NONE = 0x00,
} ICM426XX_CHIP_CONFIG_RESET_t;

/*
 * MPUREG_OTP_SEC_STATUS_B1
 * Register Name: OTP_SEC_STATUS
 */
#define BIT_OTP_SEC_STATUS_OTP_DONE	  0x10

/*
 * MPUREG_SELF_TEST_CONFIG
 * Register Name: SELF_TEST_CONFIG
*/
#define BIT_ST_REGULATOR_EN                 0x40
#define BIT_ACCEL_Z_ST_EN                   0x20
#define BIT_ACCEL_Y_ST_EN                   0x10
#define BIT_ACCEL_X_ST_EN                   0x08
#define BIT_GYRO_Z_ST_EN                    0x04
#define BIT_GYRO_Y_ST_EN                    0x02
#define BIT_GYRO_X_ST_EN                    0x01

static const u16 SelfTestEquation[256] = {
	2620, 2646, 2672, 2699, 2726, 2753, 2781, 2808,
	2837, 2865, 2894, 2923, 2952, 2981, 3011, 3041,
	3072, 3102, 3133, 3165, 3196, 3228, 3261, 3293,
	3326, 3359, 3393, 3427, 3461, 3496, 3531, 3566,
	3602, 3638, 3674, 3711, 3748, 3786, 3823, 3862,
	3900, 3939, 3979, 4019, 4059, 4099, 4140, 4182,
	4224, 4266, 4308, 4352, 4395, 4439, 4483, 4528,
	4574, 4619, 4665, 4712, 4759, 4807, 4855, 4903,
	4953, 5002, 5052, 5103, 5154, 5205, 5257, 5310,
	5363, 5417, 5471, 5525, 5581, 5636, 5693, 5750,
	5807, 5865, 5924, 5983, 6043, 6104, 6165, 6226,
	6289, 6351, 6415, 6479, 6544, 6609, 6675, 6742,
	6810, 6878, 6946, 7016, 7086, 7157, 7229, 7301,
	7374, 7448, 7522, 7597, 7673, 7750, 7828, 7906,
	7985, 8065, 8145, 8227, 8309, 8392, 8476, 8561,
	8647, 8733, 8820, 8909, 8998, 9088, 9178, 9270,
	9363, 9457, 9551, 9647, 9743, 9841, 9939, 10038,
	10139, 10240, 10343, 10446, 10550, 10656, 10763, 10870,
	10979, 11089, 11200, 11312, 11425, 11539, 11654, 11771,
	11889, 12008, 12128, 12249, 12371, 12495, 12620, 12746,
	12874, 13002, 13132, 13264, 13396, 13530, 13666, 13802,
	13940, 14080, 14221, 14363, 14506, 14652, 14798, 14946,
	15096, 15247, 15399, 15553, 15709, 15866, 16024, 16184,
	16346, 16510, 16675, 16842, 17010, 17180, 17352, 17526,
	17701, 17878, 18057, 18237, 18420, 18604, 18790, 18978,
	19167, 19359, 19553, 19748, 19946, 20145, 20347, 20550,
	20756, 20963, 21173, 21385, 21598, 21814, 22033, 22253,
	22475, 22700, 22927, 23156, 23388, 23622, 23858, 24097,
	24338, 24581, 24827, 25075, 25326, 25579, 25835, 26093,
	26354, 26618, 26884, 27153, 27424, 27699, 27976, 28255,
	28538, 28823, 29112, 29403, 29697, 29994, 30294, 30597,
	30903, 31212, 31524, 31839, 32157, 32479, 32804
};

#define SELF_TEST_PRECISION		100
#define SELF_TEST_ACC_SHIFT_DELTA	50 /* = 0.5 */
#define SELF_TEST_GYR_SHIFT_DELTA	50 /* = 0.5 */
#define SELF_TEST_MIN_ACC_MG		225 /* mg */
#define SELF_TEST_MAX_ACC_MG		675 /* mg */
#define SELF_TEST_MIN_GYR_DPS		60  /* dps */
#define SELF_TEST_MAX_GYR_DPS		20  /* dps */
#define DEF_GYRO_SENS_TDK               (76) /* 0.0076 * 10000 */
#define DEF_SCALE_FOR_FLOAT             (10000)


#define	MG_TO_LSB (32768 / (16 >> 3) / 1000) /* 2G */
#define DPS_TO_LSB (32768 / (2000 >> 3)) /* 250dps */

#define SELF_TEST_MIN_ACC (SELF_TEST_MIN_ACC_MG * MG_TO_LSB * SELF_TEST_PRECISION)
#define SELF_TEST_MAX_ACC (SELF_TEST_MAX_ACC_MG * MG_TO_LSB * SELF_TEST_PRECISION)
#define SELF_TEST_MIN_GYR (SELF_TEST_MIN_GYR_DPS * DPS_TO_LSB * SELF_TEST_PRECISION)
#define SELF_TEST_MAX_GYR (SELF_TEST_MAX_GYR_DPS * DPS_TO_LSB * SELF_TEST_PRECISION)

/* IDLE */
#define BIT_PWR_MGMT_0_IDLE_POS        4
#define BIT_PWR_MGMT_0_IDLE_MASK   (0x01 << BIT_PWR_MGMT_0_IDLE_POS)

typedef enum
{
	ICM426XX_PWR_MGMT_0_IDLE_DIS = (0x01 << BIT_PWR_MGMT_0_IDLE_POS),
	ICM426XX_PWR_MGMT_0_IDLE_EN  = (0x00 << BIT_PWR_MGMT_0_IDLE_POS),
} ICM426XX_PWR_MGMT_0_IDLE_t;

/*
 * MPUREG_SCAN0
 * Register Name: SCAN0
*/
#define BIT_DMP_MEM_ACCESS_EN		0x08
#define BIT_MEM_OTP_ACCESS_EN		0x04
#define BIT_FIFO_MEM_RD_SYS			0x02
#define BIT_FIFO_MEM_WR_SER			0x01

/* Custom SRAM image containing Tilt/HighG/LowG */
uint8_t dmp_image[] = {
#include "Icm426xx_dmp_sram_img.h"
};

#define ICM_DMP_DOWNLOAD_RETRY 5

/*
 * Accelerometer FSR.
 */
#define ICM_ACCEL_FSR ICM426XX_ACCEL_CONFIG0_FS_SEL_8g

/*
 * Tilt wait time
 * Use type ICM426XX_APEX_CONFIG4_TILT_WAIT_TIME_t to define the number of accelerometer samples
 * to wait before triggering tilt event.
 * These types are defined in Icm426xxDefs.h.
 */
#define ICM_TILT_WAIT_TIME          ICM426XX_APEX_CONFIG4_TILT_WAIT_TIME_0

/*
 * Accelerometer and gyroscope fequencies.
 * Use type ICM426XX_ACCEL_CONFIG0_ODR_t to define accel frequency.
 */
#define ICM_ACCEL_FREQ         ICM426XX_ACCEL_CONFIG0_ODR_100_HZ
#define ICM_ACCEL_GESTURE_FREQ ICM426XX_ACCEL_CONFIG0_ODR_50_HZ

/*
 * Accelerometer filter BW.
 */
#define ICM_ACCEL_FILT_BW  ICM426XX_GYRO_ACCEL_CONFIG0_ACCEL_FILT_BW_10
#define ICM_ACCEL_FILT_ORD ICM426XX_ACCEL_CONFIG_ACCEL_UI_FILT_ORD_3RD_ORDER

/*
 * Gyroscope FSR.
 */
#define ICM_GYRO_FSR ICM426XX_GYRO_CONFIG0_FS_SEL_1000dps

/*
 * Gyroscope filter BW.
 */
#define ICM_GYRO_FILT_BW  ICM426XX_GYRO_ACCEL_CONFIG0_GYRO_FILT_BW_2


inv_icm426xx_interrupt_parameter_t config_int1 = {(inv_icm426xx_interrupt_value)0};
inv_icm426xx_interrupt_parameter_t config_int2 = {(inv_icm426xx_interrupt_value)0};


static int icm42605m_write_data_with_mask(struct icm42605m_data *cdata,
					u8 reg_addr, u8 mask, u8 data, bool b_lock)
{
	int err;
	u8 new_data, old_data = 0x00;
	err = cdata->tf->read(cdata, reg_addr, 1, &old_data, b_lock);

	if (err < 0)
		return err;

	new_data = old_data;
	new_data &= (u8)~mask;
	new_data |= (u8)data;

	return cdata->tf->write(cdata, reg_addr, 1, &new_data, b_lock);
}

static int icm42605m_enable_sensors(struct icm42605m_data *cdata, int sindex);
static int icm42605m_disable_sensors(struct icm42605m_data *cdata, int sindex);
int icm42605m_acc_open_calibration(struct icm42605m_data *cdata);

static int save_settings(struct icm42605m_data *cdata,
	struct recover_regs * saved_regs)
{
	int ret = 0;

	ret = cdata->tf->read(cdata, MPUREG_INTF_CONFIG1, 1,
		&saved_regs->intf_config1, true);
	ret |= cdata->tf->read(cdata, MPUREG_PWR_MGMT_0, 1,
		&saved_regs->pwr_mgmt_0, true);
	ret |= cdata->tf->read(cdata, MPUREG_ACCEL_CONFIG0, 1,
		&saved_regs->accel_config0, true);
	ret |= cdata->tf->read(cdata, MPUREG_ACCEL_CONFIG1, 1,
		&saved_regs->accel_config1, true);
	ret |= cdata->tf->read(cdata, MPUREG_GYRO_CONFIG0, 1,
		&saved_regs->gyro_config0, true);
	ret |= cdata->tf->read(cdata, MPUREG_GYRO_CONFIG1, 1,
		&saved_regs->gyro_config1, true);
	ret |= cdata->tf->read(cdata, MPUREG_ACCEL_GYRO_CONFIG0, 1,
		&saved_regs->accel_gyro_config0, true);
	ret |= cdata->tf->read(cdata, MPUREG_FIFO_CONFIG1, 1,
		&saved_regs->fifo_config1, true);
	ret |= cdata->tf->read(cdata, MPUREG_FIFO_CONFIG, 1,
		&saved_regs->fifo_config, true);
	ret |= cdata->tf->read(cdata, MPUREG_INTF_CONFIG0, 1,
		&saved_regs->intf_config0, true);
	ret |= cdata->tf->read(cdata, MPUREG_SELF_TEST_CONFIG, 1,
		&saved_regs->self_test_config, true);
    SENSOR_INFO("before : %d %d %d %d",saved_regs->accel_config0, saved_regs->accel_config1,
        saved_regs->gyro_config0, saved_regs->gyro_config1);
	return ret;
}

static int recover_settings(struct icm42605m_data *cdata,
	struct recover_regs * saved_regs)
{
	int ret = 0;

	ret = cdata->tf->write(cdata, MPUREG_SELF_TEST_CONFIG, 1,
		&saved_regs->self_test_config, true);
	ret |= cdata->tf->write(cdata, MPUREG_INTF_CONFIG0, 1,
		&saved_regs->intf_config0, true);
	ret |= cdata->tf->write(cdata, MPUREG_FIFO_CONFIG, 1,
		&saved_regs->fifo_config, true);
	ret |= cdata->tf->write(cdata, MPUREG_INTF_CONFIG1, 1,
		&saved_regs->intf_config1, true);
	ret |= cdata->tf->write(cdata, MPUREG_PWR_MGMT_0, 1,
		&saved_regs->pwr_mgmt_0, true);
	ret |= cdata->tf->write(cdata, MPUREG_ACCEL_CONFIG0, 1,
		&saved_regs->accel_config0, true);
	ret |= cdata->tf->write(cdata, MPUREG_ACCEL_CONFIG1, 1,
		&saved_regs->accel_config1, true);
	ret |= cdata->tf->write(cdata, MPUREG_GYRO_CONFIG0, 1,
		&saved_regs->gyro_config0, true);
	ret |= cdata->tf->write(cdata, MPUREG_GYRO_CONFIG1, 1,
		&saved_regs->gyro_config1, true);
	ret |= cdata->tf->write(cdata, MPUREG_FIFO_CONFIG1, 1,
		&saved_regs->fifo_config1, true);
	ret |= cdata->tf->write(cdata, MPUREG_ACCEL_GYRO_CONFIG0, 1,
		&saved_regs->accel_gyro_config0, true);
	/* wait 200ms for gyro output to settle */
	usleep_range(200000,200000);

	return ret;
}

static int config_gyro(struct icm42605m_data * cdata,
	struct recover_regs * saved_reg)
{
	int ret = 0;
	u8 val;

	/* set configuration values to set ODR to 1kHz and bandwith to 100Hz */
	val = saved_reg->gyro_config1;
	val &= ~BIT_GYRO_CONFIG1_GYRO_UI_FILT_ORD_MASK;
	val &= ~BIT_GYRO_CONFIG1_GYRO_DEC2_M2_ORD_MASK;
	val |= DEFAULT_ST_GYRO_UI_FILT_ORD_IND;
	val |= DEFAULT_ST_GYRO_DEC2_M2_ORD;
	cdata->tf->write(cdata, MPUREG_GYRO_CONFIG1, 1, &val, true);

	val= saved_reg->accel_gyro_config0;
	val &= ~BIT_GYRO_ACCEL_CONFIG0_GYRO_FILT_MASK;
	val |= DEFAULT_ST_GYRO_UI_FILT_BW_IND;
	cdata->tf->write(cdata, MPUREG_ACCEL_GYRO_CONFIG0, 1, &val, true);

	val = saved_reg->gyro_config0;
	val &= ~BIT_GYRO_CONFIG0_FS_SEL_MASK;
	val &= ~BIT_GYRO_CONFIG0_ODR_MASK;
	val |= ICM426XX_GYRO_CONFIG0_FS_SEL_250dps;
	val |= ICM426XX_GYRO_CONFIG0_ODR_1_KHZ;
	ret |= cdata->tf->write(cdata, MPUREG_GYRO_CONFIG0, 1, &val, true);

	return ret;
}

static int config_accel(struct icm42605m_data * cdata,
	struct recover_regs * saved_reg)
{
	int ret = 0;
	u8 val;

	val = saved_reg->accel_gyro_config0;
	val &= ~BIT_GYRO_ACCEL_CONFIG0_ACCEL_FILT_MASK;
	val |= DEFAULT_ST_ACCEL_UI_FILT_BW_IND;
	ret |= cdata->tf->write(cdata, MPUREG_ACCEL_GYRO_CONFIG0, 1, &val, true);

	val = saved_reg->accel_config1;
	val &= ~BIT_ACCEL_CONFIG1_ACCEL_UI_FILT_ORD_MASK;
	val |= DEFAULT_ST_ACCEL_UI_FILT_ORD_IND;
	ret |= cdata->tf->write(cdata, MPUREG_ACCEL_CONFIG1, 1, &val, true);

	val = saved_reg->accel_config0;
	val &= ~BIT_ACCEL_CONFIG0_FS_SEL_MASK;
	val &= ~BIT_ACCEL_CONFIG0_ODR_MASK;
	val |= ICM426XX_ACCEL_CONFIG0_FS_SEL_2g;
	val |= ICM426XX_ACCEL_CONFIG0_ODR_1_KHZ;
	ret |= cdata->tf->write(cdata, MPUREG_ACCEL_CONFIG0, 1, &val, true);

	return ret;
}

static int do_average_on_sensor_output(struct icm42605m_data *cdata,
	int sindex, int self_test_flag, s32 sensor_result[3])
{
	int ret = 0;
	int it = 0, sample_discarded = 0, timeout;
	u8 data, data_pwr_mgmt, reg, ST_sensor_data[6];
	s16 ST_buffer[3] = {0};
	s32 ST_sum[3] = {0};

	if(sindex == ICM42605M_GYRO) {
		/* Enable Gyro */
		ret = icm42605m_write_data_with_mask(cdata,
			MPUREG_PWR_MGMT_0, BIT_PWR_MGMT_0_GYRO_MODE_MASK,
			ICM426XX_PWR_MGMT_0_GYRO_MODE_LN, true);
		/* wait for 60ms to allow output to settle */
		usleep_range(60000,60000);
		reg = MPUREG_GYRO_DATA_X0_UI;
	}
	else if(sindex == ICM42605M_ACCEL) {
		ret = icm42605m_write_data_with_mask(cdata,
			MPUREG_PWR_MGMT_0, BIT_PWR_MGMT_0_ACCEL_MODE_MASK,
			ICM426XX_PWR_MGMT_0_ACCEL_MODE_LN, true);
		/* wait for 25ms to allow output to settle */
		usleep_range(25000,25000);
		reg = MPUREG_ACCEL_DATA_X0_UI;
	}
	else
		return ret;

	if(self_test_flag) {
		cdata->tf->read(cdata, MPUREG_SELF_TEST_CONFIG, 1, &data, true);
		data |= self_test_flag;
		cdata->tf->write(cdata, MPUREG_SELF_TEST_CONFIG, 1, &data, true);
		if(sindex == ICM42605M_GYRO) {
			/* wait 200ms for the oscillation to stabilize */
			usleep_range(200000,200000);
		} else {
			/* wait for 25ms to allow output to settle */
            usleep_range(25000,25000);
		}
	}

	timeout = 200;
	do {
		u8 int_status;
		cdata->tf->read(cdata, MPUREG_INT_STATUS, 1, &int_status, true);
		if (int_status & BIT_INT_STATUS_DRDY) {
			cdata->tf->read(cdata, reg, 6, ST_sensor_data, true);
			ST_buffer[0] = (ST_sensor_data[0] << 8) | ST_sensor_data[1];
			ST_buffer[1] = (ST_sensor_data[2] << 8) | ST_sensor_data[3];
			ST_buffer[2] = (ST_sensor_data[4] << 8) | ST_sensor_data[5];
			if ((ST_buffer[0] != -32768)
				&& (ST_buffer[1] != -32768) && (ST_buffer[2] != -32768)) {
				ST_sum[0] += ST_buffer[0];
				ST_sum[1] += ST_buffer[1];
				ST_sum[2] += ST_buffer[2];
			} else {
				sample_discarded ++;
			}
			it ++;
		}
		usleep_range(1000,1000);
		timeout --;
	} while((it < 200) && (timeout > 0));

	/* Disable Accel and Gyro */
	ret |= cdata->tf->read(cdata, MPUREG_PWR_MGMT_0, 1, &data_pwr_mgmt, true);
	data_pwr_mgmt &= (u8)~BIT_PWR_MGMT_0_GYRO_MODE_MASK;
	data_pwr_mgmt &= (u8)~BIT_PWR_MGMT_0_ACCEL_MODE_MASK;
	data_pwr_mgmt |= (u8)ICM426XX_PWR_MGMT_0_GYRO_MODE_OFF;
	data_pwr_mgmt |= (u8)ICM426XX_PWR_MGMT_0_ACCEL_MODE_OFF;
	ret |= cdata->tf->write(cdata, MPUREG_PWR_MGMT_0, 1, &data_pwr_mgmt, true);

	it -= sample_discarded;
	sensor_result[0] = (ST_sum[0] / it) * SELF_TEST_PRECISION;
	sensor_result[1] = (ST_sum[1] / it) * SELF_TEST_PRECISION;
	sensor_result[2] = (ST_sum[2] / it) * SELF_TEST_PRECISION;

	if(self_test_flag) {
		data &= ~self_test_flag;
		ret |= cdata->tf->write(cdata, MPUREG_SELF_TEST_CONFIG, 1, &data, true);
	}

	return ret;
}

/*
 * check_gyro_self_test
 * Param  result: 1 if success, 0 if failure
 * Returns 0 if success, error code if failure
 */
static int check_gyro_self_test(struct icm42605m_data *cdata,
	struct recover_regs * saved_reg, int * result)
{
	int ret = 0, i = 0, otp_value_zero = 0, gyro_bias;
	u8 bank, regs[3];
	s32 ST_OFF_gyro[3], ST_ON_gyro[3];
	u32 ST_gyro_res[3], ST_gyro_otp[3];

	*result = 1;

	/** Check Gyro self-test response */
	ret |= config_gyro(cdata, saved_reg);

	/* read average gyro digital output for each axis and store them as ST_OFF_{x,y,z} in lsb */
	ret |= do_average_on_sensor_output(cdata, ICM42605M_GYRO, 0, ST_OFF_gyro);

	/* enable self-test for each axis */
	/* then read average gyro digital output for each axis and store them as ST_ON_{x,y,z} in lsb */
	ret |= do_average_on_sensor_output(cdata, ICM42605M_GYRO, (BIT_GYRO_X_ST_EN + BIT_GYRO_Y_ST_EN + BIT_GYRO_Z_ST_EN), ST_ON_gyro);

	/* calculate the self-test response as ABS(ST_ON_{x,y,z} - ST_OFF_{x,y,z}) for each axis */
	for(i = 0; i < 3; i++) {
		ST_gyro_res[i] = ST_ON_gyro[i] - ST_OFF_gyro[i];
	}

	/* calculate ST results OTP based on the equation */
	bank = 1;
	ret |= cdata->tf->write(cdata, MPUREG_REG_BANK_SEL, 1, &bank, true);
	ret |= cdata->tf->read(cdata, MPUREG_XG_ST_DATA_B1, 3, regs, true);
	for (i = 0; i < 3; i++) {
		if (regs[i] != 0) {
			ST_gyro_otp[i] = SelfTestEquation[regs[i] - 1];
		} else {
			ST_gyro_otp[i] = 0;
			otp_value_zero = 1;
		}
	}
	bank = 0;
	ret |= cdata->tf->write(cdata, MPUREG_REG_BANK_SEL, 1, &bank, true);

	/** Check Gyro self-test results */
	if (!otp_value_zero) {
		for (i = 0; i < 3; i++) {
            /* criteria a */
            s32 ratio = (s32)(ST_gyro_res[i] / ST_gyro_otp[i]);
            cdata->gyro_st_ratio[i] = ratio;
            SENSOR_INFO("gyro self %d", cdata->gyro_st_ratio[i]);
			if (ratio <= SELF_TEST_GYR_SHIFT_DELTA) {
				SENSOR_ERR("error gyro[%d] : st_res = %d, st_otp = %d\n",
					i, ST_gyro_res[i], ST_gyro_otp[i]);
				*result = 0; /* fail */
			}
		}
	} else {
		/* criteria b */
		for (i = 0; i < 3; i++) {
			if (abs(ST_gyro_res[i]) < SELF_TEST_MIN_GYR) {
				SENSOR_ERR("error gyro[%d] : st_res = %d, min = %d\n",
					i, ST_gyro_res[i], SELF_TEST_MIN_GYR);
				*result = 0; /* fail */
			}
		}
	}
	if (*result) {
		/* criteria c */
		for (i = 0; i < 3; i++) {
			gyro_bias = abs(ST_OFF_gyro[i]);
			if (gyro_bias > SELF_TEST_MAX_GYR) {
				SENSOR_ERR("error gyro[%d] = %d, max = %d\n",
					i, gyro_bias, SELF_TEST_MAX_GYR);
				*result = 0; /* fail */
			}
		}
	}


    /* SEC specific,  */
	for(i = 0; i < 3; i++) {
        SENSOR_INFO("ST OFF %d ST ON %d", ST_OFF_gyro[i], ST_ON_gyro[i]);
		cdata->gyro_st_off_data[i] = ST_OFF_gyro[i] / SELF_TEST_PRECISION;
		cdata->gyro_st_on_data[i] = ST_ON_gyro[i] / SELF_TEST_PRECISION;
	}

#if 0
	/* stored the computed bias (checking GST and GOFFSET values) */
	for (i = 0; i < 3; i++) {
		if((INV_ABS(ST_OFF_gyro[i]) > (s32)(MAX_DEFAULT_ST_GYRO_OFFSET_DPS * (32768 / 250))))
			*result = 0; /* fail */
		s->gyro_st_bias[i] = ST_OFF_gyro[i];
	}

	/* SEC specific,  */
	for(i = 0; i < 3; i++) {
		s->gyro_st_off_data[i] = ST_OFF_gyro[i];
		s->gyro_st_on_data[i] = ST_ON_gyro[i];
	}
#endif

	return ret;
}

/*
 * check_accel_self_test
 * Param  result: 1 if success, 0 if failure
 * Returns 0 if success, error code if failure
 */
static int check_accel_self_test(struct icm42605m_data *cdata,
	struct recover_regs * saved_reg, int * result)
{
	int ret = 0, i, otp_value_zero = 0;/*axis, axis_sign;*/
	u8 bank, regs[3];
	s32 ST_OFF_accel[3], ST_ON_accel[3];
	u32 ST_accel_res[3], ST_accel_otp[3];
	//u32 gravity;

	*result = 1;

	/** Check Accel self-test */

	ret |= config_accel(cdata, saved_reg);

	/* read average accel digital output for each axis
		and store them as ST_OFF_{x,y,z} in lsb x 1000 */
	ret |= do_average_on_sensor_output(cdata, ICM42605M_ACCEL, 0,
		ST_OFF_accel);

	/* enable self-test for each axis */
	/* then read average gyro digital output for each axis
		and store them as ST_ON_{x,y,z} in lsb x 1000 */
	ret |= do_average_on_sensor_output(cdata, ICM42605M_ACCEL,
		(BIT_ACCEL_X_ST_EN + BIT_ACCEL_Y_ST_EN
			+ BIT_ACCEL_Z_ST_EN
			+ BIT_ST_REGULATOR_EN),
			ST_ON_accel);

	/* calculate the self-test response
		as ABS(ST_ON_{x,y,z} - ST_OFF_{x,y,z}) for each axis */
	/* outputs from this routine are in units of lsb
		and hence are dependent on the full-scale used on the DUT */
	for(i = 0; i < 3; i++) {
		ST_accel_res[i] = ST_ON_accel[i] - ST_OFF_accel[i];
	}

	/* calculate ST results OTP based on the equation */
	bank = 2;
	ret = cdata->tf->write(cdata, MPUREG_REG_BANK_SEL, 1, &bank, true);
	ret |= cdata->tf->read(cdata, MPUREG_XA_ST_DATA_B2, 3, regs, true);
	for (i = 0; i < 3; i++) {
		if (regs[i] != 0) {
			ST_accel_otp[i] = SelfTestEquation[regs[i] - 1];
		} else {
			ST_accel_otp[i] = 0;
			otp_value_zero = 1;
		}
	}
	bank = 0;
	ret |= cdata->tf->write(cdata, MPUREG_REG_BANK_SEL, 1, &bank, true);

	/** Check Accel self-test result */

	/* verify 'PASS' criteria:
	 * - (a) 0.5 < AST/AST_OTP < 1.5 or,
	 * - (b) 225mgee <= AST <= 675mgee
	 */
	for (i = 0; i < 3; i++) {
		if (!otp_value_zero) {
			s32 ratio = (s32)(ST_accel_res[i] / ST_accel_otp[i]);
			cdata->accel_st_ratio[i] = ratio;
            SENSOR_INFO("acc self %d", cdata->accel_st_ratio[i]);
			if ((ratio >= 150) || (ratio <= SELF_TEST_GYR_SHIFT_DELTA))
				*result = 0; /* fail */
		} else if ((ST_accel_res[i] < ((MIN_DEFAULT_ST_ACCEL_MG * (32768 / 2)) / 1000))
				|| (ST_accel_res[i] > ((MAX_DEFAULT_ST_ACCEL_MG * (32768 / 2)) / 1000))) {
			*result = 0; /* fail */
		}
	}

#if 0
	/* stored the computed offset */
	for(i = 0; i < 3; i++) {
		s->accel_st_bias[i] = ST_OFF_accel[i];
	}

	/* assume the largest data axis shows +1 or -1 gee for gravity */
	axis = 0;
	axis_sign = 1;
	if (INV_ABS(s->accel_st_bias[1]) > INV_ABS(s->accel_st_bias[0]))
		axis = 1;
	if (INV_ABS(s->accel_st_bias[2]) > INV_ABS(s->accel_st_bias[axis]))
		axis = 2;
	if (s->accel_st_bias[axis] < 0)
		axis_sign = -1;

	gravity = (32768 / 2) * axis_sign;
	s->accel_st_bias[axis] -= gravity;

	/* SEC specific,  */
	for(i = 0; i < 3; i++) {
		s->accel_st_off_data[i] = ST_OFF_accel[i];
		s->accel_st_on_data[i] = ST_ON_accel[i];
	}
#endif

	return ret;
}

int check_fifo_self_test(struct icm42605m_data *cdata,
	struct recover_regs * saved_reg, s32 * fifo_result)
{
#define PACKET_SIZE 16
#define MAX_FIFO_READ 32
#define BUFFER_SIZE 128
#define RETRY_NUM 3
	int ret = 0;
	u8 data[2], int_status, tmp;
	u16 packet_count;
	u16 total_bytes;
	u8 fifo[BUFFER_SIZE];
	s16 gyro[3] = {0};
	s32 gyro_sum[3] = {0}, gyro_avg[3], gyro_cnt = 0;
	s32 i, j, k, retry = RETRY_NUM;

retry_test:

	*fifo_result = 1;

	ret |= config_gyro(cdata, saved_reg);
	ret |= config_accel(cdata, saved_reg);
	ret |= icm42605m_write_data_with_mask(cdata,
		MPUREG_PWR_MGMT_0,
		BIT_PWR_MGMT_0_GYRO_MODE_MASK,
		ICM426XX_PWR_MGMT_0_GYRO_MODE_LN, true);
	usleep_range(60000,60000);
	ret |= icm42605m_write_data_with_mask(cdata,
		MPUREG_FIFO_CONFIG,
		BIT_FIFO_CONFIG_MODE_MASK,
		ICM426XX_FIFO_CONFIG_MODE_STREAM, true);
	ret |= icm42605m_write_data_with_mask(cdata,
		MPUREG_INTF_CONFIG0,
		BIT_FIFO_COUNT_ENDIAN_MASK,
		ICM426XX_INTF_CONFIG0_FIFO_COUNT_REC_RECORD, true);
	ret |= icm42605m_write_data_with_mask(cdata,
		MPUREG_FIFO_CONFIG1,
		0xFF,
		0x00, true);
	ret |= icm42605m_write_data_with_mask(cdata,
		MPUREG_SIGNAL_PATH_RESET,
		BIT_SIGNAL_PATH_RESET_FIFO_FLUSH_MASK,
		ICM426XX_SIGNAL_PATH_RESET_FIFO_FLUSH_EN, true);
	ret |= icm42605m_write_data_with_mask(cdata,
		MPUREG_FIFO_CONFIG1,
		0xFF,
		ICM426XX_FIFO_CONFIG1_ACCEL_EN
		| ICM426XX_FIFO_CONFIG1_GYRO_EN
		| ICM426XX_FIFO_CONFIG1_TEMP_EN, true);
	i = 0;
	do {
		usleep_range(200000,200000);
		ret |= cdata->tf->read(cdata, MPUREG_INT_STATUS, 1, &int_status, true);
		i++;
	} while (!(int_status & BIT_INT_STATUS_FIFO_FULL) && (i < 3));
	if (i == 3) {
		*fifo_result = 0; /* fail */
		return -1;
	}
	ret |= cdata->tf->read(cdata, MPUREG_FIFO_BYTE_COUNT1, 2, data, true);
	packet_count = (data[1] << 8) | data[0];
	if (packet_count > 129 || packet_count < 125) {
		*fifo_result = 0; /* fail */
		return -1;
	}
	total_bytes = packet_count*16;
	i = 0;
	gyro_cnt = 0;
	while (total_bytes > 0) {
		if (total_bytes < MAX_FIFO_READ)
			tmp = total_bytes;
		else
			tmp = MAX_FIFO_READ;
		ret |= cdata->tf->read(cdata, MPUREG_FIFO_DATA, tmp, &fifo[i], true);
		i += tmp;
		total_bytes -= tmp;
		if (i == BUFFER_SIZE || total_bytes == 0) {
			j = 0;
			while (j < (i/PACKET_SIZE)) {
				for (k = 0 ; k < 3 ; k++) {
					gyro[k] = (fifo[7+k*2+j*16] << 8) | fifo[8+k*2+j*16];
				}
				if ((gyro[0] != -32768) && (gyro[1] != -32768) && (gyro[2] != -32768)) {
					for (k = 0; k < 3; k++) {
						gyro_sum[k] += gyro[k];
						if (abs(gyro[k]) > 1310) {// check bit [15:12], 31dps~250dps
						    cdata->gyro_fifo_data[0] = gyro[0];
                            cdata->gyro_fifo_data[1] = gyro[1];
                            cdata->gyro_fifo_data[2] = gyro[2];
							*fifo_result = 0; /* fail */
                            SENSOR_ERR("GFF %d %d %d", cdata->gyro_fifo_data[0]
                                ,cdata->gyro_fifo_data[1], cdata->gyro_fifo_data[2]);
                            return ret;
						}
					}
					gyro_cnt++;
				}
				j++;
			}
			i = 0;
		}
	}

	for (k = 0; k < 3; k++) {
		gyro_avg[k] = gyro_sum[k]/gyro_cnt;
        cdata->gyro_fifo_data[k] = gyro_avg[k];
		if (abs(gyro_avg[k]) > 1310) //check offset 10dps
			*fifo_result = 0; /* fail */
	}

	retry--;
	if (*fifo_result == 0 && retry)
		goto retry_test;

    return ret;
}

static int inv_icm426xx_resume_dmp(struct icm42605m_data *cdata)
{
	int ret = 0;
	u8 reg, val, mask;
	const int ref_timeout = 50; /*50 ms*/
	int timeout = ref_timeout;

	reg = MPUREG_SIGNAL_PATH_RESET;
	mask = BIT_SIGNAL_PATH_RESET_DMP_INIT_MASK;
	val = ICM426XX_SIGNAL_PATH_RESET_DMP_INIT_EN;
	ret = icm42605m_write_data_with_mask(cdata, reg, mask, val, true);
	if (ret < 0)
		SENSOR_ERR("failed %d\n", ret);
	else
		SENSOR_INFO("Register(0x%x) data(0x%x)\n", reg, val);
	usleep_range(10000, 10000); /* need delay at least 10000us */
	/* Wait for DMP idle */
	do {
		ret = cdata->tf->read(cdata, MPUREG_APEX_DATA3, 1, &val, true);
		if (ret < 0)
			return ret;
		usleep_range(10, 10);
	} while ((0 == (val & BIT_APEX_DATA3_DMP_IDLE_MASK)) && timeout--);

	if (timeout <= 0)
		return -1;

	return ret;
}

static int inv_icm426xx_reset_dmp(struct icm42605m_data *cdata)
{
	int ret = 0;
	u8 reg, val;
	const int ref_timeout = 50; /*50 ms*/
	int timeout = ref_timeout;

	val = ICM426XX_SIGNAL_PATH_RESET_DMP_MEM_RESET_EN;
	ret = cdata->tf->write(cdata, MPUREG_SIGNAL_PATH_RESET, 1, &val, true);
	if (ret < 0)
		SENSOR_ERR("failed %d\n", ret);
	else
		SENSOR_INFO("Register(0x%x) data(0x%x)\n", reg, val);
	usleep_range(1000,1000);
	do {
		ret = cdata->tf->read(cdata, MPUREG_SIGNAL_PATH_RESET, 1, &val, true);
		if (ret < 0)
			return ret;
		usleep_range(10,10);
	} while ((val & BIT_SIGNAL_PATH_RESET_DMP_MEM_RESET_MASK) && timeout--);
	if (timeout <= 0)
		return -1;

	return ret;
}


int inv_icm426xx_start_dmp(struct icm42605m_data *cdata)
{
	int status = 0;

	/* On first enabling of DMP, reset internal state */
	if (!cdata->dmp_is_on) {
		if (!cdata->dmp_from_sram) {
			// Reset SRAM to 0's if execution from ROM
			// otherwise, it's user responsibility to do it.
			status |= inv_icm426xx_reset_dmp(cdata);
		}
		cdata->dmp_is_on = 1;
	}

	/* Initialize DMP */
	status |= inv_icm426xx_resume_dmp(cdata);

	return status;
}

int inv_icm426xx_set_config_int1(struct icm42605m_data *cdata,
	inv_icm426xx_interrupt_parameter_t * interrupt_to_configure)
{
	int ret = 0;
	u8 val[3] = {0};
	u8 bank;

	/* Set INT_SOURCE0 bits */
	val[0] |= ((interrupt_to_configure->INV_ICM426XX_FIFO_THS!= 0) << BIT_INT_FIFO_THS_INT_EN_POS);
	val[0] |= ((interrupt_to_configure->INV_ICM426XX_FIFO_FULL != 0) << BIT_INT_FIFO_FULL_INT_EN_POS);
	val[0] |= ((interrupt_to_configure->INV_ICM426XX_UI_DRDY != 0) << BIT_INT_UI_DRDY_INT_EN_POS);

	/* Set INT_SOURCE1 bits */
	val[1] |= ((interrupt_to_configure->INV_ICM426XX_SMD != 0) << BIT_INT_SMD_INT_EN_POS);
	val[1] |= ((interrupt_to_configure->INV_ICM426XX_WOM_X != 0) << BIT_INT_WOM_X_INT_EN_POS);
	val[1] |= ((interrupt_to_configure->INV_ICM426XX_WOM_Y != 0) << BIT_INT_WOM_Y_INT_EN_POS);
	val[1] |= ((interrupt_to_configure->INV_ICM426XX_WOM_Z != 0) << BIT_INT_WOM_Z_INT_EN_POS);

	/* Set INT_SOURCE6 bits */
	val[2] |= ((interrupt_to_configure->INV_ICM426XX_TILT_DET != 0) << BIT_INT_TILT_DET_INT_EN_POS);
	val[2] |= ((interrupt_to_configure->INV_ICM426XX_LOWG_DET != 0) << BIT_INT_LOWG_DET_INT_EN_POS);

	bank = 4;
	ret |= cdata->tf->write(cdata, MPUREG_REG_BANK_SEL, 1, &bank, true);
	ret |= cdata->tf->write(cdata, MPUREG_INT_SOURCE6_B4, 1, &val[2], true);
	bank = 0;
	ret |= cdata->tf->write(cdata, MPUREG_REG_BANK_SEL, 1, &bank, true);
	ret |= cdata->tf->write(cdata, MPUREG_INT_SOURCE0, 2, val, true);

	return ret;
}

int inv_icm426xx_set_config_int2(struct icm42605m_data *cdata,
	inv_icm426xx_interrupt_parameter_t * interrupt_to_configure)
{
	int ret = 0;
	u8 val[3] = {0};
	u8 bank;

	/* Set INT_SOURCE3 bits */
	val[0] |= ((interrupt_to_configure->INV_ICM426XX_FIFO_THS != 0) << BIT_INT_FIFO_THS_INT_EN_POS);
	val[0] |= ((interrupt_to_configure->INV_ICM426XX_FIFO_FULL != 0) << BIT_INT_FIFO_FULL_INT_EN_POS);
	val[0] |= ((interrupt_to_configure->INV_ICM426XX_UI_DRDY != 0) << BIT_INT_UI_DRDY_INT_EN_POS);

	/* Set INT_SOURCE4 bits */
	val[1] |= ((interrupt_to_configure->INV_ICM426XX_SMD != 0) << BIT_INT_SMD_INT_EN_POS);
	val[1] |= ((interrupt_to_configure->INV_ICM426XX_WOM_X != 0) << BIT_INT_WOM_X_INT_EN_POS);
	val[1] |= ((interrupt_to_configure->INV_ICM426XX_WOM_Y != 0) << BIT_INT_WOM_Y_INT_EN_POS);
	val[1] |= ((interrupt_to_configure->INV_ICM426XX_WOM_Z != 0) << BIT_INT_WOM_Z_INT_EN_POS);

	/* Set INT_SOURCE7 bits */
	val[2] |= ((interrupt_to_configure->INV_ICM426XX_TILT_DET != 0) << BIT_INT_TILT_DET_INT_EN_POS);
	val[2] |= ((interrupt_to_configure->INV_ICM426XX_LOWG_DET != 0) << BIT_INT_LOWG_DET_INT_EN_POS);

	bank = 4;
	ret |= cdata->tf->write(cdata, MPUREG_REG_BANK_SEL, 1, &bank, true);
	ret |= cdata->tf->write(cdata, MPUREG_INT_SOURCE7_B4, 1, &val[2], true);
	bank = 0;
	ret |= cdata->tf->write(cdata, MPUREG_REG_BANK_SEL, 1, &bank, true);
	ret |= cdata->tf->write(cdata, MPUREG_INT_SOURCE3, 2, val, true);

	return ret;
}

int inv_icm426xx_configure_fifo(struct icm42605m_data *cdata,
	INV_ICM426XX_FIFO_CONFIG_t fifo_config)
{
	int status = 0;
	u8 data;

	switch (fifo_config) {

		case INV_ICM426XX_FIFO_ENABLED :
			/* Configure:
			 * - FIFO record mode i.e FIFO count unit is packet
			 * - FIFO snapshot mode i.e drop the data when the FIFO overflows
			 * - Timestamp is logged in FIFO
			 * - Little Endian fifo_count
			*/
			status |= cdata->tf->read(cdata, MPUREG_INTF_CONFIG0, 1, &data, true);
			data |= (u8)ICM426XX_INTF_CONFIG0_FIFO_COUNT_REC_RECORD;
			data &= (u8)~BIT_FIFO_COUNT_ENDIAN_MASK; // little endian
			status |= cdata->tf->write(cdata, MPUREG_INTF_CONFIG0, 1, &data, true);
			status |= cdata->tf->read(cdata, MPUREG_FIFO_CONFIG, 1, &data, true);
			data = (u8)ICM426XX_FIFO_CONFIG_MODE_SNAPSHOT;
			status |= cdata->tf->write(cdata, MPUREG_FIFO_CONFIG, 1, &data, true);
			status |= cdata->tf->read(cdata, MPUREG_FIFO_CONFIG1, 1, &data, true);
			data |= (BIT_FIFO_CONFIG1_GYRO_MASK
				| BIT_FIFO_CONFIG1_ACCEL_MASK
				| BIT_FIFO_CONFIG1_TEMP_MASK
				| BIT_FIFO_CONFIG1_TMST_FSYNC_MASK);
			status |= cdata->tf->write(cdata, MPUREG_FIFO_CONFIG1, 1, &data, true);
			break;

		case INV_ICM426XX_FIFO_DISABLED :
			/* make sure FIFO is disabled */
			data = ICM426XX_FIFO_CONFIG_MODE_BYPASS;
			status |= cdata->tf->write(cdata, MPUREG_FIFO_CONFIG, 1, &data, true);
			break;

		default :
			status = -1;
	}
	return status;
}

int inv_icm426xx_set_accel_fsr(struct icm42605m_data *cdata,
	ICM426XX_ACCEL_CONFIG0_FS_SEL_t accel_fsr_g)
{
	u8 accel_fsr;

	accel_fsr = (u8)accel_fsr_g;
	return icm42605m_write_data_with_mask(cdata,
		MPUREG_ACCEL_CONFIG0, BIT_ACCEL_CONFIG0_FS_SEL_MASK, accel_fsr, true);
}

int inv_icm426xx_set_gyro_fsr(struct icm42605m_data *cdata,
	ICM426XX_GYRO_CONFIG0_FS_SEL_t gyro_fsr_dps)
{
	u8 gyro_fsr;

	gyro_fsr = (u8)gyro_fsr_dps;
	return icm42605m_write_data_with_mask(cdata,
		MPUREG_GYRO_CONFIG0, BIT_GYRO_CONFIG0_FS_SEL_MASK, gyro_fsr, true);
}

int inv_icm426xx_set_accel_ln_bw(struct icm42605m_data *cdata,
	ICM426XX_GYRO_ACCEL_CONFIG0_ACCEL_FILT_BW_t acc_bw)
{
	u8 accel_ln_bw;

	accel_ln_bw = (u8)acc_bw;
	return icm42605m_write_data_with_mask(cdata,
		MPUREG_ACCEL_GYRO_CONFIG0, BIT_GYRO_ACCEL_CONFIG0_ACCEL_FILT_MASK, accel_ln_bw, true);
}

int inv_icm426xx_set_gyro_ln_bw(struct icm42605m_data *cdata,
	ICM426XX_GYRO_ACCEL_CONFIG0_GYRO_FILT_BW_t gyr_bw)
{
	u8 gyro_ln_bw;

	gyro_ln_bw = (u8)gyr_bw;
	return icm42605m_write_data_with_mask(cdata,
		MPUREG_ACCEL_GYRO_CONFIG0, BIT_GYRO_ACCEL_CONFIG0_GYRO_FILT_MASK, gyro_ln_bw, true);
}

int inv_icm426xx_set_accel_frequency(struct icm42605m_data *cdata,
	const ICM426XX_ACCEL_CONFIG0_ODR_t frequency)
{
	u8 accel_frq;

	accel_frq = (u8)frequency;
	return icm42605m_write_data_with_mask(cdata,
		MPUREG_ACCEL_CONFIG0, BIT_ACCEL_CONFIG0_ODR_MASK, accel_frq, true);
}

int inv_icm426xx_set_gyro_frequency(struct icm42605m_data *cdata,
	const ICM426XX_GYRO_CONFIG0_ODR_t frequency)
{
	u8 gyro_frq;

	gyro_frq = (u8)frequency;
	return icm42605m_write_data_with_mask(cdata,
		MPUREG_GYRO_CONFIG0, BIT_GYRO_CONFIG0_ODR_MASK, gyro_frq, true);
}

int inv_icm426xx_configure_apex_parameters(struct icm42605m_data *cdata,
	const inv_icm426xx_apex_parameters_t *apex_inputs)
{
	int status = 0;
	u8 data, data2[7] = {0,};

	status |= cdata->tf->read(cdata, MPUREG_APEX_CONFIG0, 1, &data, true);

	/* Tilt parameter (APEX_CONFIG4) */
	data2[3] = apex_inputs->tilt_wait_time;

	/* Power Save mode parameters (APEX_CONFIG0, APEX_CONFIG1) */
	data &= (u8)~BIT_APEX_CONFIG0_DMP_POWER_SAVE_MASK;
	data |= (u8)apex_inputs->power_save;
	status |= cdata->tf->write(cdata, MPUREG_APEX_CONFIG0, 1, &data, true);
	/* Set memory bank 4 */
	data = 4;
	status |= cdata->tf->write(cdata, MPUREG_REG_BANK_SEL, 1, &data, true);
	/* Access continuous config registers (CONFIG1-CONFIG6) */
	status |= cdata->tf->write(cdata, MPUREG_APEX_CONFIG1_B4, 6, data2, true);
	data2[0] = ICM_WOM_THRESHOLD; /* Set X threshold */
	data2[1] = ICM_WOM_THRESHOLD; /* Set Y threshold */
	data2[2] = ICM_WOM_THRESHOLD; /* Set Z threshold */
	status |= cdata->tf->write(cdata, MPUREG_ACCEL_WOM_X_THR_B4, 3, &data2[0], true);
	status |= cdata->tf->read(cdata, MPUREG_APEX_CONFIG4_B4, 2, &data2[0], true);
	/* Spare bank sel transaction since CONFIG9 is also in bank 4 (but not contiguous) */
	status |= cdata->tf->write(cdata, MPUREG_APEX_CONFIG9_B4, 1, &data2[6], true);
	/* Set memory bank 0 */
	data = 0;
	status |= cdata->tf->write(cdata, MPUREG_REG_BANK_SEL, 1, &data, true);
	data2[0] = ((u8)ICM426XX_SMD_CONFIG_WOM_INT_MODE_ORED | (u8)ICM426XX_SMD_CONFIG_WOM_MODE_CMP_PREV);
	status |= cdata->tf->write(cdata, MPUREG_SMD_CONFIG, 1, &data2[0], true);

	return status;
}

int inv_icm426xx_set_apex_frequency(struct icm42605m_data *cdata,
	const ICM426XX_APEX_CONFIG0_DMP_ODR_t frequency)
{
	u8 data;
	int status = 0;

	status |= cdata->tf->read(cdata, MPUREG_APEX_CONFIG0, 1, &data, true);
	data &= (u8)~BIT_APEX_CONFIG0_DMP_ODR_MASK;
	data |= (u8)frequency;
	status |= cdata->tf->write(cdata, MPUREG_APEX_CONFIG0, 1, &data, true);

	return status;
}

static int icm42605m_set_extra_dependency(struct icm42605m_data *cdata,
					bool enable)
{
	int ret = 0;
	u8 reg, val, mask;

	SENSOR_INFO("Acc sensor status = %d",(cdata->enabled & ICM42605M_ACCEL_DEPENDENCY));

	if (!(cdata->enabled & ICM42605M_ACCEL_DEPENDENCY)) {
		if (enable) {
			ret = inv_icm426xx_set_accel_frequency(cdata, ICM_ACCEL_GESTURE_FREQ);
			reg = MPUREG_PWR_MGMT_0;
			mask = BIT_PWR_MGMT_0_ACCEL_MODE_MASK;
			val = ICM426XX_PWR_MGMT_0_ACCEL_MODE_LN;
			ret |= icm42605m_write_data_with_mask(cdata, reg, mask, val, true);
			if (ret < 0)
				SENSOR_ERR("failed %d\n", ret);
			else
				SENSOR_INFO("Register(0x%x) data(0x%x)\n", reg, val);
		} else {
			reg = MPUREG_PWR_MGMT_0;
			mask = BIT_PWR_MGMT_0_ACCEL_MODE_MASK;
			val = ICM426XX_PWR_MGMT_0_ACCEL_MODE_OFF;
			ret = icm42605m_write_data_with_mask(cdata, reg, mask, val, true);
			if (ret < 0)
				SENSOR_ERR("failed %d\n", ret);
			else
				SENSOR_INFO("Register(0x%x) data(0x%x)\n", reg, val);
		}
	} else {
		SENSOR_INFO("Accel sensor is on");
	}

	return 0;
}


static int icm42605m_enable_sensors(struct icm42605m_data *cdata, int sindex)
{
	int ret = 0;
	u8 reg, val, mask;
	u8 data;

	if (cdata->enabled & (1 << sindex))
		return 0;

	switch(sindex) {
	case ICM42605M_ACCEL:
		ret |= inv_icm426xx_set_accel_frequency(cdata, ICM_ACCEL_FREQ);
		reg = MPUREG_PWR_MGMT_0;
		mask = BIT_PWR_MGMT_0_ACCEL_MODE_MASK;
		val = ICM426XX_PWR_MGMT_0_ACCEL_MODE_LN;
		ret = icm42605m_write_data_with_mask(cdata, reg, mask, val, true);
		if (ret < 0)
			SENSOR_ERR("failed %d\n", ret);
		else
			SENSOR_INFO("Register(0x%x) data(0x%x)\n", reg, val);
		/* need delay at least 200us */
		usleep_range(200,200);

       	hrtimer_start(&cdata->acc_timer, cdata->acc_delay,
							HRTIMER_MODE_REL);
		break;
	case ICM42605M_GYRO:
		reg = MPUREG_PWR_MGMT_0;
		mask = BIT_PWR_MGMT_0_GYRO_MODE_MASK;
		val = ICM426XX_PWR_MGMT_0_GYRO_MODE_LN;
		ret = icm42605m_write_data_with_mask(cdata, reg, mask, val, true);
		if (ret < 0)
			SENSOR_ERR("failed %d\n", ret);
		else
			SENSOR_INFO("Register(0x%x) data(0x%x)\n", reg, val);
		/* need delay at least 200us */
		usleep_range(60000,60000);

       	hrtimer_start(&cdata->gyro_timer, cdata->gyro_delay,
							HRTIMER_MODE_REL);
		break;
	case ICM42605M_SIGN_MOTION:

		ret = icm42605m_set_extra_dependency(cdata, true);
		if (ret < 0)
			return ret;

		reg = MPUREG_SMD_CONFIG;
		mask = BIT_SMD_CONFIG_SMD_MODE_MASK;
		val = ICM426XX_SMD_CONFIG_SMD_MODE_SHORT;
		ret = icm42605m_write_data_with_mask(cdata, reg, mask, val, true);

		config_int1.INV_ICM426XX_SMD = INV_ICM426XX_ENABLE;
		ret |= inv_icm426xx_set_config_int1(cdata, &config_int1);

		if (ret < 0)
			SENSOR_ERR("failed %d\n", ret);
		else
			SENSOR_INFO("Register(0x%x) data(0x%x)\n", reg, val);
		break;
	case ICM42605M_TILT:

		ret = icm42605m_set_extra_dependency(cdata, true);
		if (ret < 0)
			return ret;

		inv_icm426xx_start_dmp(cdata);

		ret = cdata->tf->read(cdata, MPUREG_APEX_CONFIG0, 1, &data, true);
		data |= (u8)ICM426XX_APEX_CONFIG0_TILT_EN_EN;
		ret = cdata->tf->write(cdata, MPUREG_APEX_CONFIG0, 1, &data, true);

		config_int1.INV_ICM426XX_TILT_DET = INV_ICM426XX_ENABLE;
		ret |= inv_icm426xx_set_config_int1(cdata, &config_int1);

		if (ret < 0)
			SENSOR_ERR("failed %d\n", ret);
		else
			SENSOR_INFO("Register(0x%x) data(0x%x)\n", reg, val);
		break;
	default:
		return -1;
	}

	cdata->enabled |= (1 << sindex);

	SENSOR_INFO("cdata->enabled : 0x%x\n", cdata->enabled);

	return 0;
}

static int icm42605m_disable_sensors(struct icm42605m_data *cdata, int sindex)
{
	int ret = 0;
	u8 reg, val, mask;
	u8 data;

	if (!(cdata->enabled & (1 << sindex))) {
		SENSOR_INFO("Sensor disable failed! %d", sindex);
		return 0;
	}

    cdata->enabled &= ~(1 << sindex);

	switch(sindex) {
	case ICM42605M_ACCEL:
		hrtimer_cancel(&cdata->acc_timer);
		cancel_work_sync(&cdata->acc_work);

		if ((cdata->enabled & ICM42605M_EXTRA_DEPENDENCY) || (cdata->sa_flag)) {
			ret |= inv_icm426xx_set_accel_frequency(cdata, ICM_ACCEL_GESTURE_FREQ);
		} else {
			reg = MPUREG_PWR_MGMT_0;
			mask = BIT_PWR_MGMT_0_ACCEL_MODE_MASK;
			val = ICM426XX_PWR_MGMT_0_ACCEL_MODE_OFF;
			ret = icm42605m_write_data_with_mask(cdata, reg, mask, val, true);
		}

		if (ret < 0)
			SENSOR_ERR("failed %d\n", ret);
		else
			SENSOR_INFO("Register(0x%x) data(0x%x)\n", reg, val);
		/* need delay at least 200us */
		usleep_range(2000,2000);
		break;
	case ICM42605M_GYRO:
		hrtimer_cancel(&cdata->gyro_timer);
		cancel_work_sync(&cdata->gyro_work);
		reg = MPUREG_PWR_MGMT_0;
		mask = BIT_PWR_MGMT_0_GYRO_MODE_MASK;
		val = ICM426XX_PWR_MGMT_0_GYRO_MODE_OFF;
		ret = icm42605m_write_data_with_mask(cdata, reg, mask, val, true);
		if (ret < 0)
			SENSOR_ERR("failed %d\n", ret);
		else
			SENSOR_INFO("Register(0x%x) data(0x%x)\n", reg, val);
		/* need delay at least 50ms */
		usleep_range(50000,50000);
		break;
	case ICM42605M_SIGN_MOTION:

        ret = icm42605m_set_extra_dependency(cdata, true);
		if (ret < 0)
			return ret;

		reg = MPUREG_SMD_CONFIG;
		mask = BIT_SMD_CONFIG_SMD_MODE_MASK;
		val = ICM426XX_SMD_CONFIG_SMD_MODE_DISABLED;
		ret = icm42605m_write_data_with_mask(cdata, reg, mask, val, true);

		config_int1.INV_ICM426XX_SMD = INV_ICM426XX_DISABLE;
		ret |= inv_icm426xx_set_config_int1(cdata, &config_int1);

		if (ret < 0)
			SENSOR_ERR("failed %d\n", ret);
		else
			SENSOR_INFO("Register(0x%x) data(0x%x)\n", reg, val);
		break;
	case ICM42605M_TILT:

		ret = icm42605m_set_extra_dependency(cdata, true);
		if (ret < 0){
			SENSOR_INFO("Tilt dependency!!");
			return ret;
		}
		ret = cdata->tf->read(cdata, MPUREG_APEX_CONFIG0, 1, &data, true);
		data &= (u8)~BIT_APEX_CONFIG0_TILT_EN_MASK;
		ret = cdata->tf->write(cdata, MPUREG_APEX_CONFIG0, 1, &data, true);

		config_int1.INV_ICM426XX_TILT_DET = INV_ICM426XX_DISABLE;
		ret |= inv_icm426xx_set_config_int1(cdata, &config_int1);

		if (ret < 0)
			SENSOR_ERR("failed %d\n", ret);
		else
			SENSOR_INFO("Register(0x%x) data(0x%x)\n", reg, val);
		break;
	default:
		return -1;
	}

	SENSOR_INFO("cdata->enabled : 0x%x\n", cdata->enabled);

	return 0;
}

//Remained
static int icm42605m_read_data(struct icm42605m_data *cdata, int sindex, u8 *data)
{
	int ret = 0;
	u8 reg;

	switch(sindex) {
	case ICM42605M_ACCEL:
        reg = MPUREG_ACCEL_DATA_X0_UI;
		break;
	case ICM42605M_GYRO:
        reg = MPUREG_GYRO_DATA_X0_UI;
		break;
	default:
		return -1;
	}
	ret = cdata->tf->read(cdata, reg, 6, data, true);

	return ret;
}


/* Accelerometer LPF */
static int icm42605m_set_lpf(struct icm42605m_data *cdata, int onoff)
{
	int ret = 0;
	u8 reg, val, mask;
	ICM426XX_ACCEL_CONFIG0_ODR_t frequency = ICM_ACCEL_FREQ;
	reg = MPUREG_ACCEL_GYRO_CONFIG0;
	mask = BIT_GYRO_ACCEL_CONFIG0_ACCEL_FILT_MASK;
	if (onoff) {
		val = ICM426XX_GYRO_ACCEL_CONFIG0_ACCEL_FILT_BW_10;
		SENSOR_INFO("ICM42605M-LPF On\n");
	} else {
		val = ICM426XX_GYRO_ACCEL_CONFIG0_ACCEL_FILT_BW_2;
		frequency = ICM426XX_ACCEL_CONFIG0_ODR_1_KHZ;
		SENSOR_INFO("ICM42605M-LPF Off\n");
	}

	//Set LPF(Low Pass Filter)
	ret = icm42605m_write_data_with_mask(cdata, reg, mask, val, true);
	if (ret < 0)
		SENSOR_ERR("failed %d\n", ret);
	else
		SENSOR_INFO("Register(0x%x) data(0x%x)\n", reg, val);

	//Set frequency dynamically(100HZ and 1KHZ)
	ret |= inv_icm426xx_set_accel_frequency(cdata, frequency);

	cdata->lpf_on = onoff;

	return ret;
}

/* Accelerometer Selftest */
/*static int icm42605m_acc_hw_selftest(struct icm42605m_data *cdata,
		s32 *NOST, s32 *ST, s32 *N_ST, s32 *DIFF_ST, s32 *N_DIFF_ST)
{
	int ret, gyro_result;
	struct recover_regs saved_regs;

	ret = save_settings(cdata, &saved_regs);
	ret |= check_accel_self_test(cdata, &saved_regs, &gyro_result);
	ret |= recover_settings(cdata, &saved_regs);

	// TO-DO

//XL_HW_SELF_EXIT:
	return ret;
}*/

/* Gyro fifotest */
/*static int icm42605m_gyro_fifo_test(struct icm42605m_data *cdata,
		s16 *zero_rate_lsb, s32 *fifo_cnt, u8 *fifo_pass,
		s16 *slot_raw, char *out_str)
{
	int ret;
	struct recover_regs saved_regs;

	ret = save_settings(cdata, &saved_regs);
	ret |= check_fifo_self_test(cdata, &saved_regs, fifo_pass);
	ret |= recover_settings(cdata, &saved_regs);

	// TO-DO

//G_HW_SELF_EXIT:
	return ret;
}*/


static int icm42605m_selftest_run(struct icm42605m_data *cdata,
			char *out_str, u8 sindex)
{
	int ret;
	//u8 zero[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
	struct recover_regs saved_regs;
	s32 fifo_pass = 0;
	u8 self_test_ret = FAIL, self_test_zro_ret = FAIL;
	s16 gyro_fifo_data[3] = {0,};
	s32 gyro_self_zro[3] = {0,}, gyro_self_bias[3] = {0,};//, N_ST[3] = {0,};
	s32 DIFF_ST[3] = {0,}, N_DIFF_ST[3] = {0,};
    s32 gyroRatio[3] = {0, };
	s32 /*fifo_count = 0,*/ hw_st_ret = 0;
	int i = 0;

	SENSOR_INFO("start\n");

	/* hw selftest */
	switch (sindex) {
	case ICM42605M_ACCEL:
		ret = save_settings(cdata, &saved_regs);
		ret |= check_accel_self_test(cdata, &saved_regs, &hw_st_ret);
		ret |= recover_settings(cdata, &saved_regs);
		break;
	case ICM42605M_GYRO:
		ret = save_settings(cdata, &saved_regs);
		ret |= check_fifo_self_test(cdata, &saved_regs, &fifo_pass);
        if (fifo_pass > 0) {
			self_test_zro_ret = PASS;
			SENSOR_INFO("gyro fifotest pass\n");
		} else {
			self_test_zro_ret = FAIL;
			SENSOR_INFO("gyro fifotest fail\n");
		}
		ret |= recover_settings(cdata, &saved_regs);
		ret = save_settings(cdata, &saved_regs);
		ret |= check_gyro_self_test(cdata, &saved_regs, &hw_st_ret);
		ret |= recover_settings(cdata, &saved_regs);
		if (hw_st_ret > 0) {
			self_test_ret = PASS;
			SENSOR_INFO("gyro fifotest pass\n");
		} else {
			self_test_ret = FAIL;
			SENSOR_INFO("gyro fifotest fail\n");
		}
		break;
	}

	switch (sindex) {
	case ICM42605M_ACCEL:

        //Set ratio data for accelerometer selftest
        for(i = 0; i < 3; i++) {
            DIFF_ST[i] = cdata->accel_st_ratio[i];
        }
        if (hw_st_ret > 0) {
			return snprintf(out_str, PAGE_SIZE, "1,%d,%d,%d,%d,%d,%d\n",
					DIFF_ST[0], DIFF_ST[1], DIFF_ST[2],
					N_DIFF_ST[0], N_DIFF_ST[1], N_DIFF_ST[2]);
		} else {
			return snprintf(out_str, PAGE_SIZE, "0,%d,%d,%d,%d,%d,%d\n",
					DIFF_ST[0], DIFF_ST[1], DIFF_ST[2],
					N_DIFF_ST[0], N_DIFF_ST[1], N_DIFF_ST[2]);
		}
		break;
	case ICM42605M_GYRO:
        for(i = 0;i < 3;i++) {
            gyro_self_bias[i] = cdata->gyro_st_on_data[i] * DEF_GYRO_SENS_TDK / DEF_SCALE_FOR_FLOAT;//dps
            gyro_self_zro[i] = cdata->gyro_st_off_data[i] * DEF_GYRO_SENS_TDK / DEF_SCALE_FOR_FLOAT;//dps
            gyroRatio[i] = cdata->gyro_st_ratio[i];
            gyro_fifo_data[i] = cdata->gyro_fifo_data[i] * DEF_GYRO_SENS_TDK / DEF_SCALE_FOR_FLOAT;//dps
        }
		if (!fifo_pass) {
			return snprintf(out_str, PAGE_SIZE, "%d,%d,%d\n",
				gyro_fifo_data[0], gyro_fifo_data[1], gyro_fifo_data[2]);
		} else {
			SENSOR_INFO("zero_rate_data = %d, %d, %d, st = %d, %d, %d, "\
				"nost = %d, %d, %d, diff_st = %d, %d, %d, "\
				"self_test_ret = %d, self_test_zro_ret = %d\n",
				gyro_fifo_data[0], gyro_fifo_data[1],
				gyro_fifo_data[2], gyro_self_zro[0], gyro_self_zro[1], gyro_self_zro[2],
				gyro_self_bias[0], gyro_self_bias[1], gyro_self_bias[2],
				gyroRatio[0], gyroRatio[1], gyroRatio[2],
				self_test_ret, self_test_zro_ret);

			return snprintf(out_str, PAGE_SIZE,
				"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d\n",
				gyro_fifo_data[0], gyro_fifo_data[1],
				gyro_fifo_data[2], gyro_self_zro[0], gyro_self_zro[1], gyro_self_zro[2],
				gyro_self_bias[0], gyro_self_bias[1], gyro_self_bias[2], gyroRatio[0], gyroRatio[1],
				gyroRatio[2], self_test_ret, self_test_zro_ret);
		}
		break;
	}

	// TO-DO

	return 0;
}

void icm42605m_set_irq(struct icm42605m_data *cdata, bool enable)
{
	if (enable) {
		cdata->states++;
		SENSOR_INFO("enable state count:(%d)\n", cdata->states);
		if (cdata->states == 1) {
			SENSOR_INFO("enable irq come (%d)\n", cdata->irq);
			enable_irq_wake(cdata->irq);
			enable_irq(cdata->irq);
		}
	} else if (cdata->states != 0 && enable == 0) {
		cdata->states--;
		if (cdata->states == 0) {
			disable_irq_wake(cdata->irq);
			disable_irq_nosync(cdata->irq);
			SENSOR_INFO("disable irq come (%d)\n", cdata->irq);
		}
		SENSOR_INFO("disable state count:(%d)\n", cdata->states);
	}
}


irqreturn_t icm42605m_threaded(int irq, void *private)
{
	struct icm42605m_data *cdata = private;

	queue_work(cdata->irq_wq, &cdata->data_work);

	return IRQ_HANDLED;
}

static void icm42605m_sa_irq_work(struct work_struct *work)
{
	struct icm42605m_data *cdata;

	cdata = container_of((struct delayed_work *)work,
				struct icm42605m_data, sa_irq_work);

	SENSOR_INFO("SA IRQ WORK!!");

	icm42605m_set_extra_dependency(cdata, false);

	config_int1.INV_ICM426XX_UI_DRDY = INV_ICM426XX_DISABLE;
	inv_icm426xx_set_config_int1(cdata, &config_int1);

	cdata->sa_factory_work= 1;

	return;
}

static void icm42605m_irq_management(struct work_struct *data_work)
{
	struct icm42605m_data *cdata;
	s32 rc = 0;
	u8 int_status[2];
	u8 src_value = 0;

	cdata = container_of((struct work_struct *)data_work,
					struct icm42605m_data, data_work);

	SENSOR_INFO("IRQ Occur");

	usleep_range(10000, 11000);

#ifdef FEATURE_LATCHEDMODE
		/* read status register to clear interrupt */
		rc = cdata->tf->read(cdata, MPUREG_INT_STATUS, 1, &int_status[0], true);
		if (rc != INV_ERROR_SUCCESS) {
			SENSOR_ERR("!!! ERROR : failed to read accel data.");
			return;
		}
#endif
		if(cdata->sa_factory_flag == 1) {
			src_value = (int_status[0] & BIT_INT_STATUS_DRDY) ? ACC_INT_DRDY : 0;
		}

		rc = cdata->tf->read(cdata, MPUREG_INT_STATUS2, 2, int_status, true);
		if (rc != INV_ERROR_SUCCESS) {
			SENSOR_ERR("!!! ERROR : failed to read accel data.");
			return;
		}
		//TODO by TDK : It needs to get smd interrupt
		src_value |= (int_status[0] & BIT_INT_STATUS2_SMD_INT) ? ACC_INT_SMD : 0;
		src_value |= (int_status[1] & BIT_INT_STATUS3_TILT_DET) ? ACC_INT_TILT : 0;


	//DRDY callback
	if(src_value & ACC_INT_DRDY) {
		SENSOR_INFO("DRDY Event");
		if(cdata->sa_factory_flag == 1) {
			cdata->sa_irq_state = 1;
			wake_lock_timeout(&cdata->sa_wake_lock, msecs_to_jiffies(3000));
			schedule_delayed_work(&cdata->sa_irq_work,
			msecs_to_jiffies(20));
		} else {
			SENSOR_INFO("Skip DRDY event");
		}
	}

	//Significant motion callback
	if (src_value & ACC_INT_SMD) {
		SENSOR_INFO("SMD Event");
		input_report_rel(cdata->smd_input, REL_MISC, 1);
		input_sync(cdata->smd_input);
		wake_lock_timeout(&cdata->sa_wake_lock, msecs_to_jiffies(3000));
	}

	//Tilt motion callback
	if (src_value & ACC_INT_TILT) {
		if(cdata->sa_flag == 1) {
			SENSOR_INFO("Smart Alert Event");
			cdata->sa_irq_state = 1;
		}

		if (cdata->tilt_flag == 1) {
			SENSOR_INFO("TILT Event");
			input_report_rel(cdata->tilt_input, REL_MISC, 1);
			input_sync(cdata->tilt_input);
			wake_lock_timeout(&cdata->sa_wake_lock, msecs_to_jiffies(3000));
		}
	}

}

/* work func */
static enum hrtimer_restart icm42605m_gyro_timer_func(struct hrtimer *timer)
{
	struct icm42605m_data *cdata = container_of(timer,
					struct icm42605m_data, gyro_timer);

#ifdef CONFIG_SENSORS_icm42605m_SUPPORT_VDIS
	queue_kthread_work(&cdata->gyro_worker, &cdata->gyro_work);
#else
	if (!work_pending(&cdata->gyro_work))
		queue_work(cdata->gyro_wq, &cdata->gyro_work);
#endif

	hrtimer_forward_now(&cdata->gyro_timer, cdata->gyro_delay);

	return HRTIMER_RESTART;
}

static enum hrtimer_restart icm42605m_acc_timer_func(struct hrtimer *timer)
{
	struct icm42605m_data *cdata = container_of(timer,
					struct icm42605m_data, acc_timer);

	if (!work_pending(&cdata->acc_work))
		queue_work(cdata->accel_wq, &cdata->acc_work);

	hrtimer_forward_now(&cdata->acc_timer, cdata->acc_delay);

	return HRTIMER_RESTART;
}

static void icm42605m_acc_work_func(struct work_struct *work)
{
	struct icm42605m_data *cdata =
		container_of(work, struct icm42605m_data, acc_work);

	//int n;
	int err;
	u8 data[6];
	s16 raw_data[3];

	err = icm42605m_read_data(cdata, ICM42605M_ACCEL, data);
	if (err < 0)
		goto exit;

	/*for (n = 0; n < 3; n++) {
		raw_data[n] = *((s16 *)&data[2 * n]);
		if (raw_data[n] == -32768)
			raw_data[n] = -32767;
	}*/

    raw_data[0] = (data[0] << 8) | data[1];
    raw_data[1] = (data[2] << 8) | data[3];
    raw_data[2] = (data[4] << 8) | data[5];

   // SENSOR_INFO("%d Before acc x = %d, y = %d, z = %d\n",cdata->position ,
	//		raw_data[0],
	//		raw_data[1], raw_data[2]);

	remap_sensor_data(raw_data, cdata->position);

	cdata->accel_data[0] = raw_data[0] - cdata->accel_cal_data[0];
	cdata->accel_data[1] = raw_data[1] - cdata->accel_cal_data[1];
	cdata->accel_data[2] = raw_data[2] - cdata->accel_cal_data[2];

    //SENSOR_INFO("After acc x = %d, y = %d, z = %d\n",
	//		raw_data[0],
	//		raw_data[1], raw_data[2]);

	input_report_rel(cdata->acc_input, REL_X, cdata->accel_data[0]);
	input_report_rel(cdata->acc_input, REL_Y, cdata->accel_data[1]);
	input_report_rel(cdata->acc_input, REL_Z, cdata->accel_data[2]);
	input_sync(cdata->acc_input);

exit:
	if ((ktime_to_ns(cdata->acc_delay) * cdata->acc_time_count)
			>= ((int64_t)ACCEL_LOG_TIME * NSEC_PER_SEC)) {
		SENSOR_INFO("x = %d, y = %d, z = %d\n",
			cdata->accel_data[0],
			cdata->accel_data[1], cdata->accel_data[2]);
		cdata->acc_time_count = 0;
	} else {
		cdata->acc_time_count++;
	}
}


static void icm42605m_gyro_work_func(struct work_struct *work)
{
    struct icm42605m_data *cdata =
            container_of(work, struct icm42605m_data, gyro_work);

        //int n;
        int err;
        u8 data[6];
        s16 raw_data[3];

        err = icm42605m_read_data(cdata, ICM42605M_GYRO, data);
        if (err < 0)
            goto exit;

        /* Applying rotation matrix */
        /*for (n = 0; n < 3; n++) {
            raw_data[n] = *((s16 *)&data[2 * n]);
            if (raw_data[n] == -32768)
                raw_data[n] = -32767;
        }*/
        raw_data[0] = (data[0] << 8) | data[1];
        raw_data[1] = (data[2] << 8) | data[3];
        raw_data[2] = (data[4] << 8) | data[5];
        
        remap_sensor_data(raw_data, cdata->position);

        cdata->gyro_data[0] = raw_data[0];
        cdata->gyro_data[1] = raw_data[1];
        cdata->gyro_data[2] = raw_data[2];

        //SENSOR_INFO("gyro x = %d, y = %d, z = %d\n",
        //        raw_data[0],
        //        raw_data[1], raw_data[2]);

        input_report_rel(cdata->gyro_input, REL_RX, cdata->gyro_data[0]);
        input_report_rel(cdata->gyro_input, REL_RY, cdata->gyro_data[1]);
        input_report_rel(cdata->gyro_input, REL_RZ, cdata->gyro_data[2]);
        input_sync(cdata->gyro_input);

    exit:
        if ((ktime_to_ns(cdata->gyro_delay) * cdata->gyro_time_count)
                >= ((int64_t)ACCEL_LOG_TIME * NSEC_PER_SEC)) {
            SENSOR_INFO("x = %d, y = %d, z = %d\n",
                cdata->gyro_data[0],
                cdata->gyro_data[1], cdata->gyro_data[2]);
            cdata->gyro_time_count = 0;
        } else {
            cdata->gyro_time_count++;
        }

}


static ssize_t icm42605m_acc_delay_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	struct input_dev *input = to_input_dev(dev);
	struct icm42605m_data *cdata = input_get_drvdata(input);

	return snprintf(buf, 16, "%lld\n", ktime_to_ns(cdata->acc_delay));
}

static ssize_t icm42605m_acc_delay_store(struct device *dev,
		struct device_attribute *attr,
		const char *buf, size_t count)
{
	struct input_dev *input = to_input_dev(dev);
	struct icm42605m_data *cdata = input_get_drvdata(input);
	int err;
	unsigned long data;

	err = kstrtoul(buf, 10, &data);
	if (err)
		return count;

	if (data == 0)
		return count;

	if (data > ICM42605M_DELAY_DEFAULT)
		data = ICM42605M_DELAY_DEFAULT;

	cdata->acc_delay = ns_to_ktime(data);

	SENSOR_INFO("new_delay = %lld\n", ktime_to_ns(cdata->acc_delay));

	return count;
}

static ssize_t icm42605m_acc_enable_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	struct input_dev *input = to_input_dev(dev);
	struct icm42605m_data *cdata = input_get_drvdata(input);

	return snprintf(buf, 16, "%d\n", atomic_read(&cdata->acc_wkqueue_en));

}

static ssize_t icm42605m_acc_enable_store(struct device *dev,
		struct device_attribute *attr,
		const char *buf, size_t count)
{
	struct input_dev *input = to_input_dev(dev);
	struct icm42605m_data *cdata = input_get_drvdata(input);
	int err;
	u8 enable;
	int pre_enable = atomic_read(&cdata->acc_wkqueue_en);

	err = kstrtou8(buf, 10, &enable);
	if (err)
		return count;

	enable = enable ? 1 : 0;

	SENSOR_INFO("new_value = %d, pre_enable = %d\n", enable, pre_enable);

	mutex_lock(&cdata->mutex_enable);

	if (enable){
		icm42605m_enable_sensors(cdata, ICM42605M_ACCEL);
        atomic_set(&cdata->acc_wkqueue_en, 1);
	} else {
	    atomic_set(&cdata->acc_wkqueue_en, 0);
		icm42605m_disable_sensors(cdata, ICM42605M_ACCEL);
	}

	mutex_unlock(&cdata->mutex_enable);

	return count;
}

static ssize_t icm42605m_gyro_delay_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	struct input_dev *input = to_input_dev(dev);
	struct icm42605m_data *cdata = input_get_drvdata(input);

	return snprintf(buf, 16, "%lld\n", ktime_to_ns(cdata->gyro_delay));
}

static ssize_t icm42605m_gyro_delay_store(struct device *dev,
		struct device_attribute *attr,
		const char *buf, size_t count)
{
	struct input_dev *input = to_input_dev(dev);
	struct icm42605m_data *cdata = input_get_drvdata(input);
	int err;
	unsigned long data;

	err = kstrtoul(buf, 10, &data);
	if (err)
		return err;

	if (data == 0)
		return count;

	if (data > ICM42605M_DELAY_DEFAULT)
		data = ICM42605M_DELAY_DEFAULT;

	cdata->gyro_delay = ns_to_ktime(data);

	SENSOR_INFO("new_delay = %lld\n", ktime_to_ns(cdata->gyro_delay));

	return count;
}

static ssize_t icm42605m_gyro_enable_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	struct input_dev *input = to_input_dev(dev);
	struct icm42605m_data *cdata = input_get_drvdata(input);

	return sprintf(buf, "%d\n", atomic_read(&cdata->gyro_wkqueue_en));
}

static ssize_t icm42605m_gyro_enable_store(struct device *dev,
		struct device_attribute *attr,
		const char *buf, size_t count)
{
	struct input_dev *input = to_input_dev(dev);
	struct icm42605m_data *cdata = input_get_drvdata(input);
	int err;
	u8 enable;
	int pre_enable = atomic_read(&cdata->gyro_wkqueue_en);

	err = kstrtou8(buf, 10, &enable);
	if (err)
		return count;

	enable = enable ? 1 : 0;

	SENSOR_INFO("new_value = %d, pre_enable = %d\n", enable, pre_enable);

	mutex_lock(&cdata->mutex_enable);

	if (enable) {
        icm42605m_enable_sensors(cdata, ICM42605M_GYRO);
        atomic_set(&cdata->gyro_wkqueue_en, 1);
	} else {
	    atomic_set(&cdata->gyro_wkqueue_en, 0);
		icm42605m_disable_sensors(cdata, ICM42605M_GYRO);
	}

	mutex_unlock(&cdata->mutex_enable);

	return count;
}

static ssize_t icm42605m_smd_enable_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	struct input_dev *input = to_input_dev(dev);
	struct icm42605m_data *cdata = input_get_drvdata(input);
	int ret;

	if (cdata->enabled & (1 << ICM42605M_SIGN_MOTION))
		ret = 1;
	else
		ret = 0;

	return snprintf(buf, 16, "%d\n", ret);
}

static ssize_t icm42605m_smd_enable_store(struct device *dev,
		struct device_attribute *attr,
		const char *buf, size_t count)
{
	struct input_dev *input = to_input_dev(dev);
	struct icm42605m_data *cdata = input_get_drvdata(input);
	int err;
	u8 enable;

	err = kstrtou8(buf, 10, &enable);
	if (err)
		return count;

	enable = enable ? 1 : 0;

	SENSOR_INFO("new_value = %d\n",	enable);

	mutex_lock(&cdata->mutex_enable);

	if (enable) {
		icm42605m_enable_sensors(cdata, ICM42605M_SIGN_MOTION);
	} else {
		icm42605m_disable_sensors(cdata, ICM42605M_SIGN_MOTION);
	}

	icm42605m_set_irq(cdata, enable);
	mutex_unlock(&cdata->mutex_enable);

	return count;
}

static ssize_t icm42605m_tilt_enable_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	struct input_dev *input = to_input_dev(dev);
	struct icm42605m_data *cdata = input_get_drvdata(input);
	int ret;

	if (cdata->enabled & (1 << ICM42605M_TILT))
		ret = 1;
	else
		ret = 0;

	return snprintf(buf, 16, "%d\n", ret);

}

static ssize_t icm42605m_tilt_enable_store(struct device *dev,
		struct device_attribute *attr,
		const char *buf, size_t count)
{
	struct input_dev *input = to_input_dev(dev);
	struct icm42605m_data *cdata = input_get_drvdata(input);
	int err;
	u8 enable;

	err = kstrtou8(buf, 10, &enable);
	if (err)
		return count;

	enable = enable ? 1 : 0;

	SENSOR_INFO("new_value = %d\n",	enable);

	mutex_lock(&cdata->mutex_enable);

	cdata->tilt_flag = enable;

	if (enable){
		icm42605m_enable_sensors(cdata, ICM42605M_TILT);
	} else {
		if(cdata->sa_flag == 0) {
			icm42605m_disable_sensors(cdata, ICM42605M_TILT);
		} else {
			SENSOR_INFO("Smart alert already reigstered!!");
		}
	}

	icm42605m_set_irq(cdata, enable);
	mutex_unlock(&cdata->mutex_enable);

	return count;
}


static struct device_attribute dev_attr_acc_poll_delay =
	__ATTR(poll_delay, S_IRUGO|S_IWUSR,
	icm42605m_acc_delay_show,
	icm42605m_acc_delay_store);
static struct device_attribute dev_attr_acc_enable =
	__ATTR(enable, S_IRUGO|S_IWUSR,
	icm42605m_acc_enable_show,
	icm42605m_acc_enable_store);

static struct attribute *icm42605m_acc_attributes[] = {
	&dev_attr_acc_poll_delay.attr,
	&dev_attr_acc_enable.attr,
	NULL
};

static struct attribute_group icm42605m_accel_attribute_group = {
	.attrs = icm42605m_acc_attributes
};

static struct device_attribute dev_attr_gyro_poll_delay =
	__ATTR(poll_delay, S_IRUGO|S_IWUSR,
	icm42605m_gyro_delay_show,
	icm42605m_gyro_delay_store);
static struct device_attribute dev_attr_gyro_enable =
	__ATTR(enable, S_IRUGO|S_IWUSR,
	icm42605m_gyro_enable_show,
	icm42605m_gyro_enable_store);

static struct attribute *icm42605m_gyro_attributes[] = {
	&dev_attr_gyro_poll_delay.attr,
	&dev_attr_gyro_enable.attr,
	NULL
};

static struct attribute_group icm42605m_gyro_attribute_group = {
	.attrs = icm42605m_gyro_attributes
};


static struct device_attribute dev_attr_smd_enable =
	__ATTR(enable, S_IRUGO|S_IWUSR,
	icm42605m_smd_enable_show,
	icm42605m_smd_enable_store);

static struct attribute *icm42605m_smd_attributes[] = {
	&dev_attr_smd_enable.attr,
	NULL
};

static struct attribute_group icm42605m_smd_attribute_group = {
	.attrs = icm42605m_smd_attributes
};

static struct device_attribute dev_attr_tilt_enable =
	__ATTR(enable, S_IRUGO|S_IWUSR,
	icm42605m_tilt_enable_show,
	icm42605m_tilt_enable_store);

static struct attribute *icm42605m_tilt_attributes[] = {
	&dev_attr_tilt_enable.attr,
	NULL
};

static struct attribute_group icm42605m_tilt_attribute_group = {
	.attrs = icm42605m_tilt_attributes
};

/* FATORY SYSFS */
static ssize_t icm42605m_vendor_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%s\n", VENDOR_NAME);
}

static ssize_t icm42605m_name_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%s\n", ICM42605M_DEV_NAME);
}

static ssize_t selftest_revised_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%d\n", SELFTEST_REVISED);
}

static ssize_t icm42605m_temperature_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	int ret;
	s32 temp;
	u8 data[2];

	struct icm42605m_data *cdata = dev_get_drvdata(dev);

	ret = cdata->tf->read(cdata, MPUREG_TEMP_DATA0_UI, 2,
		data, true);
	if (ret < 0)
		SENSOR_ERR("failed to read temperature data\n", ret);

    temp = (data[0] << 8) | data[1];
    temp = ((temp * 100) / 12765) + 25;

	return snprintf(buf, PAGE_SIZE, "%d\n", temp);
}

/* Accelerometer Calibraion */
int icm42605m_acc_open_calibration(struct icm42605m_data *cdata)
{
	int ret = 0;
	mm_segment_t old_fs;
	struct file *cal_filp = NULL;

	SENSOR_INFO("\n");

	old_fs = get_fs();
	set_fs(KERNEL_DS);

	cal_filp = filp_open(CALIBRATION_FILE_PATH, O_RDONLY, 0);
	if (IS_ERR(cal_filp)) {
		set_fs(old_fs);
		ret = PTR_ERR(cal_filp);

		cdata->accel_cal_data[0] = 0;
		cdata->accel_cal_data[1] = 0;
		cdata->accel_cal_data[2] = 0;

		SENSOR_INFO("Can't open calibration file\n");
		return ret;
	}

	ret = vfs_read(cal_filp, (char *)&cdata->accel_cal_data,
		3 * sizeof(s16), &cal_filp->f_pos);
	if (ret != 3 * sizeof(s16)) {

		cdata->accel_cal_data[0] = 0;
		cdata->accel_cal_data[1] = 0;
		cdata->accel_cal_data[2] = 0;

		SENSOR_ERR("Can't read the cal data\n");
		ret = -EIO;
	}

	filp_close(cal_filp, current->files);
	set_fs(old_fs);

	SENSOR_INFO("%d, %d, %d\n",
		cdata->accel_cal_data[0], cdata->accel_cal_data[1],
		cdata->accel_cal_data[2]);

	if ((cdata->accel_cal_data[0] == 0) && (cdata->accel_cal_data[1] == 0)
		&& (cdata->accel_cal_data[2] == 0))
		return -EIO;

	return ret;
}

static int icm42605m_acc_do_calibrate(struct icm42605m_data *cdata, int enable)
{
	int sum[3] = { 0, };
	int ret = 0, cnt;
	struct file *cal_filp = NULL;
	mm_segment_t old_fs;

	SENSOR_INFO("\n");

	if (enable) {
		cdata->accel_cal_data[0] = 0;
		cdata->accel_cal_data[1] = 0;
		cdata->accel_cal_data[2] = 0;

		for (cnt = 0; cnt < CALIBRATION_DATA_AMOUNT; cnt++) {
			sum[0] += cdata->accel_data[0];
			sum[1] += cdata->accel_data[1];
			sum[2] += cdata->accel_data[2];
			msleep(20);
		}

		cdata->accel_cal_data[0] = (sum[0] / CALIBRATION_DATA_AMOUNT);
		cdata->accel_cal_data[1] = (sum[1] / CALIBRATION_DATA_AMOUNT);
		cdata->accel_cal_data[2] = (sum[2] / CALIBRATION_DATA_AMOUNT);

		if (cdata->accel_cal_data[2] > 0)
			cdata->accel_cal_data[2] -= MAX_ACCEL_1G;
		else if (cdata->accel_cal_data[2] < 0)
			cdata->accel_cal_data[2] += MAX_ACCEL_1G;

	} else {
		cdata->accel_cal_data[0] = 0;
		cdata->accel_cal_data[1] = 0;
		cdata->accel_cal_data[2] = 0;
	}

	SENSOR_INFO("do accel calibrate %d, %d, %d\n", cdata->accel_cal_data[0],
		cdata->accel_cal_data[1], cdata->accel_cal_data[2]);

	old_fs = get_fs();
	set_fs(KERNEL_DS);

	cal_filp = filp_open(CALIBRATION_FILE_PATH,
		O_CREAT | O_TRUNC | O_WRONLY, 0660);
	if (IS_ERR(cal_filp)) {
		SENSOR_ERR("Can't open calibration file\n");
		set_fs(old_fs);
		ret = PTR_ERR(cal_filp);
		return ret;
	}

	ret = vfs_write(cal_filp, (char *)&cdata->accel_cal_data,
		3 * sizeof(s16), &cal_filp->f_pos);
	if (ret != 3 * sizeof(s16)) {
		SENSOR_ERR("Can't write the caldata to file\n");
		ret = -EIO;
	}

	filp_close(cal_filp, current->files);
	set_fs(old_fs);

	return ret;
}

static ssize_t icm42605m_acc_calibration_show(struct device *dev,
	struct device_attribute *attr, char *buf)
{
	int ret;
	struct icm42605m_data *cdata = dev_get_drvdata(dev);

	SENSOR_INFO("\n");

	ret = icm42605m_acc_open_calibration(cdata);
	if (ret < 0)
		SENSOR_ERR("calibration open failed = %d\n", ret);

	SENSOR_INFO("cal data %d %d %d, ret = %d\n", cdata->accel_cal_data[0],
		cdata->accel_cal_data[1], cdata->accel_cal_data[2], ret);

	return snprintf(buf, PAGE_SIZE, "%d %d %d %d\n", ret,
		cdata->accel_cal_data[0], cdata->accel_cal_data[1],
		cdata->accel_cal_data[2]);
}

static ssize_t icm42605m_acc_calibration_store(struct device *dev,
	struct device_attribute *attr, const char *buf, size_t size)
{
	int ret;
	int64_t dEnable;
	struct icm42605m_data *cdata = dev_get_drvdata(dev);

	SENSOR_INFO("\n");

	ret = kstrtoll(buf, 10, &dEnable);
	if (ret < 0) {
		SENSOR_ERR("kstrtoll failed\n");
		return size;
	}

	ret = icm42605m_acc_do_calibrate(cdata, (int)dEnable);
	if (ret < 0)
		SENSOR_ERR("accel calibrate failed\n");

	return size;
}

static ssize_t icm42605m_lowpassfilter_show(struct device *dev,
	struct device_attribute *attr, char *buf)
{
	int ret = 0;
	struct icm42605m_data *cdata = dev_get_drvdata(dev);

	if (cdata->lpf_on)
		ret = 1;
	else
		ret = 0;

	return snprintf(buf, PAGE_SIZE, "%d\n", ret);
}

static ssize_t icm42605m_lowpassfilter_store(struct device *dev,
	struct device_attribute *attr, const char *buf, size_t size)
{
	int ret;
	int64_t dEnable;
	struct icm42605m_data *cdata;

	cdata = dev_get_drvdata(dev);
	SENSOR_INFO("\n");

	ret = kstrtoll(buf, 10, &dEnable);
	if (ret < 0)
		SENSOR_ERR("kstrtoll failed, ret = %d\n", ret);

	ret = icm42605m_set_lpf(cdata , dEnable);
	if (ret < 0)
		SENSOR_ERR("icm42605m_set_lpf failed, ret = %d\n", ret);

	return size;
}

/* reactive alert */
static ssize_t icm42605m_smart_alert_show(struct device *dev,
				struct device_attribute *attr, char *buf)
{
	struct icm42605m_data *cdata = dev_get_drvdata(dev);
	int result = 0;

	result = cdata->sa_irq_state;

	return snprintf(buf, PAGE_SIZE, "%d\n", result);
}

static ssize_t icm42605m_smart_alert_store(struct device *dev,
		struct device_attribute *attr, const char *buf, size_t size)
{
	struct icm42605m_data *cdata = dev_get_drvdata(dev);

	int enable = 0;
	int ret;

	if (sysfs_streq(buf, "0")) {
		enable = 0;
		SENSOR_INFO("disable\n");
	} else if (sysfs_streq(buf, "1")) {
		enable = 1;
		cdata->sa_factory_flag = 0;
		cdata->sa_flag = 1;
		SENSOR_INFO("enable\n");
	} else if (sysfs_streq(buf, "2")) {
		enable = 1;
		cdata->sa_factory_flag = 1;
		cdata->sa_flag = 0;
		SENSOR_INFO("factory mode\n");
	} else {
		SENSOR_ERR("invalid value %s\n", buf);
		return size;
	}

	mutex_lock(&cdata->mutex_enable);

	if (enable == 1) {
		cdata->sa_irq_state = 0;
		if(cdata->sa_factory_flag == 1) {//Factory test mode
			ret = icm42605m_set_extra_dependency(cdata, true);

			config_int1.INV_ICM426XX_UI_DRDY = INV_ICM426XX_ENABLE;
			ret |= inv_icm426xx_set_config_int1(cdata, &config_int1);
			cdata->sa_factory_work = 0;

			SENSOR_INFO("Factory test is on!\n");
		} else if (cdata->sa_flag == 1) {//Smart alert mode
			icm42605m_enable_sensors(cdata, ICM42605M_TILT);

			SENSOR_INFO("smart alert is on!\n");
		}
		icm42605m_set_irq(cdata, 1);

	} else if (enable == 0) {
		if(cdata->sa_factory_flag == 1) {//Factory test mode
			cdata->sa_factory_flag = 0;

			if(cdata->sa_factory_work == 0) {
				ret = icm42605m_set_extra_dependency(cdata, false);

				config_int1.INV_ICM426XX_UI_DRDY = INV_ICM426XX_DISABLE;
				ret |= inv_icm426xx_set_config_int1(cdata, &config_int1);
				SENSOR_INFO("Disable DRDY interrupt");
			} else {
				SENSOR_INFO("DRDY interrupt already disabled");
			}

			SENSOR_INFO("Factory test is off!\n");
		} else if (cdata->sa_flag == 1) {//Smart alert mode
			cdata->sa_flag = 0;
			if(cdata->tilt_flag == 0) {
				icm42605m_disable_sensors(cdata, ICM42605M_TILT);
			} else {
				SENSOR_INFO("Tilt already reigstered!!");
			}
			SENSOR_INFO("smart alert is off! irq = %d", cdata->sa_irq_state);
		}
		icm42605m_set_irq(cdata, 0);
	}

	mutex_unlock(&cdata->mutex_enable);

	return size;
}

/* raw_data */
static ssize_t icm42605m_acc_raw_data_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	signed short cx, cy, cz;
	struct icm42605m_data *cdata;

	cdata = dev_get_drvdata(dev);

	cx = cdata->accel_data[0];
	cy = cdata->accel_data[1];
	cz = cdata->accel_data[2];

	return snprintf(buf, PAGE_SIZE, "%d, %d, %d\n", cx, cy, cz);
}

static ssize_t icm42605m_gyro_raw_data_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	signed short cx, cy, cz;
	struct icm42605m_data *cdata;

	cdata = dev_get_drvdata(dev);

	cx = cdata->gyro_data[0];
	cy = cdata->gyro_data[1];
	cz = cdata->gyro_data[2];

	return snprintf(buf, PAGE_SIZE, "%d, %d, %d\n", cx, cy, cz);
}

static ssize_t icm42605m_acc_selftest_show(struct device *dev,
				struct device_attribute *attr, char *buf)
{
	struct icm42605m_data *cdata = dev_get_drvdata(dev);
	ssize_t ret;

	mutex_lock(&cdata->mutex_enable);
	ret = icm42605m_selftest_run(cdata, buf, ICM42605M_ACCEL);
	mutex_unlock(&cdata->mutex_enable);

	return ret;
}

static ssize_t icm42605m_gyro_selftest_show(struct device *dev,
				struct device_attribute *attr, char *buf)
{
	struct icm42605m_data *cdata = dev_get_drvdata(dev);
	ssize_t ret;

	mutex_lock(&cdata->mutex_enable);
	ret = icm42605m_selftest_run(cdata, buf, ICM42605M_GYRO);
	mutex_unlock(&cdata->mutex_enable);

	return ret;
}

static ssize_t icm42605m_write_register_store(struct device *dev,
		struct device_attribute *attr, const char *buf, size_t count)
{
	int reg, val;
	int ret;
	struct icm42605m_data *cdata = dev_get_drvdata(dev);

	if (sscanf(buf, "%2x,%2x", &reg, &val) != 2) {
		SENSOR_ERR("invalid value\n");
		return count;
	}

	ret = icm42605m_write_data_with_mask(cdata, reg, 0xff, val, true);

	if (ret < 0)
		SENSOR_ERR("failed %d\n", ret);
	else
		SENSOR_INFO("Register(0x%x) data(0x%x)\n", reg, val);

	return count;
}

static void icm42605m_read_register(struct icm42605m_data *cdata)
{
	u8 reg, offset;
	u8 reg_value[16] = {0x00,};
	u8 i, unit = 16;
	s8 ret;
	char buf[84] = {0,};

	for (reg = 0x00; reg <= 0x7f; reg+=unit) {
		ret = cdata->tf->read(cdata, reg, unit, reg_value, true);
		if (ret < 0) {
			SENSOR_ERR("[0x%02x-0x%02x]: fail %d\n", reg, reg+unit-1, ret);
		}
		else {
			offset = 0;
			for (i = 0; i < unit; i++)
				offset += snprintf(buf + offset, sizeof(buf) - offset, "0x%02x ", reg_value[i]);
			SENSOR_INFO("[0x%02x-0x%02x]:%s\n", reg, reg+unit-1, buf);
		}
	}
}

static ssize_t icm42605m_read_register_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	struct icm42605m_data *cdata = dev_get_drvdata(dev);
	icm42605m_read_register(cdata);

	return snprintf(buf, PAGE_SIZE, "%d\n", 1);
}

static DEVICE_ATTR(acc_register, S_IRUGO | S_IWUSR | S_IWGRP,
	icm42605m_read_register_show, icm42605m_write_register_store);
static DEVICE_ATTR(vendor, S_IRUGO, icm42605m_vendor_show, NULL);
static DEVICE_ATTR(name, S_IRUGO, icm42605m_name_show, NULL);
static DEVICE_ATTR(selftest_revised, S_IRUGO, selftest_revised_show, NULL);
//static DEVICE_ATTR(dhr_sensor_info, S_IRUGO, icm42605m_accel_dhr_sensor_info_show, NULL);
static DEVICE_ATTR(temperature, S_IRUGO, icm42605m_temperature_show, NULL);
static DEVICE_ATTR(calibration, S_IRUGO | S_IWUSR | S_IWGRP,
	icm42605m_acc_calibration_show, icm42605m_acc_calibration_store);
static DEVICE_ATTR(lowpassfilter, S_IRUGO | S_IWUSR | S_IWGRP,
	icm42605m_lowpassfilter_show, icm42605m_lowpassfilter_store);
static DEVICE_ATTR(reactive_alert, S_IWUSR | S_IRUGO,
				icm42605m_smart_alert_show,
				icm42605m_smart_alert_store);

static struct device_attribute dev_attr_acc_raw_data =
	__ATTR(raw_data, S_IRUGO, icm42605m_acc_raw_data_show, NULL);
static struct device_attribute dev_attr_acc_self_test =
	__ATTR(selftest, S_IRUGO,
	icm42605m_acc_selftest_show,
	NULL);

static struct device_attribute dev_attr_gyro_raw_data =
	__ATTR(raw_data, S_IRUGO, icm42605m_gyro_raw_data_show, NULL);
static struct device_attribute dev_attr_gyro_self_test =
	__ATTR(selftest, S_IRUGO,
	icm42605m_gyro_selftest_show,
	NULL);

static struct device_attribute *acc_sensor_attrs[] = {
	&dev_attr_vendor,
	&dev_attr_name,
	//&dev_attr_dhr_sensor_info,
	&dev_attr_calibration,
	&dev_attr_lowpassfilter,
	&dev_attr_reactive_alert,
	&dev_attr_acc_raw_data,
	&dev_attr_acc_self_test,
	&dev_attr_acc_register,
	NULL
};

static struct device_attribute *gyro_sensor_attrs[] = {
	&dev_attr_vendor,
	&dev_attr_name,
	&dev_attr_selftest_revised,
	&dev_attr_temperature,
	&dev_attr_gyro_raw_data,
	&dev_attr_gyro_self_test,
	NULL
};

static struct device_attribute *smd_sensor_attrs[] = {
	&dev_attr_vendor,
	&dev_attr_name,
	NULL
};

static struct device_attribute *tilt_sensor_attrs[] = {
	&dev_attr_vendor,
	&dev_attr_name,
	NULL
};

/* input init */
static int icm42605m_acc_input_init(struct icm42605m_data *cdata)
{
	int ret = 0;
	struct input_dev *dev;

	dev = input_allocate_device();
	if (!dev)
		return -ENOMEM;

	dev->name = MODULE_NAME_ACC;
	dev->id.bustype = BUS_I2C;

	input_set_capability(dev, EV_REL, REL_X);
	input_set_capability(dev, EV_REL, REL_Y);
	input_set_capability(dev, EV_REL, REL_Z);
	input_set_drvdata(dev, cdata);

	ret = input_register_device(dev);
	if (ret < 0) {
		input_free_device(dev);
		goto err_register_input_dev;
	}

	ret = sensors_create_symlink(&dev->dev.kobj, dev->name);
	if (ret < 0)
		goto err_create_sensor_symlink;

	/* sysfs node creation */
	ret = sysfs_create_group(&dev->dev.kobj,
				&icm42605m_accel_attribute_group);
	if (ret < 0)
		goto err_create_sysfs_group;

	cdata->acc_input = dev;

	return 0;

err_create_sysfs_group:
	sensors_remove_symlink(&dev->dev.kobj, dev->name);
err_create_sensor_symlink:
	input_unregister_device(dev);
err_register_input_dev:
	dev = NULL;
	return ret;
}

static int icm42605m_gyro_input_init(struct icm42605m_data *cdata)
{
	int ret = 0;
	struct input_dev *dev;

	dev = input_allocate_device();
	if (!dev)
		return -ENOMEM;

	dev->name = MODULE_NAME_GYRO;
	dev->id.bustype = BUS_I2C;

	input_set_capability(dev, EV_REL, REL_RX);
	input_set_capability(dev, EV_REL, REL_RY);
	input_set_capability(dev, EV_REL, REL_RZ);
	input_set_drvdata(dev, cdata);

	ret = input_register_device(dev);
	if (ret < 0) {
		input_free_device(dev);
		goto err_register_input_dev;
	}

	ret = sensors_create_symlink(&dev->dev.kobj, dev->name);
	if (ret < 0)
		goto err_create_sensor_symlink;

	/* sysfs node creation */
	ret = sysfs_create_group(&dev->dev.kobj,
				&icm42605m_gyro_attribute_group);
	if (ret < 0)
		goto err_create_sysfs_group;

	cdata->gyro_input = dev;

	return 0;

err_create_sysfs_group:
	sensors_remove_symlink(&dev->dev.kobj, dev->name);
err_create_sensor_symlink:
	input_unregister_device(dev);
err_register_input_dev:
	dev = NULL;
	return ret;
}

static int icm42605m_smd_input_init(struct icm42605m_data *cdata)
{
	int ret = 0;
	struct input_dev *dev;

	dev = input_allocate_device();
	if (!dev)
		return -ENOMEM;

	dev->name = MODULE_NAME_SMD;
	dev->id.bustype = BUS_I2C;

	input_set_capability(dev, EV_REL, REL_MISC);
	input_set_drvdata(dev, cdata);

	ret = input_register_device(dev);
	if (ret < 0) {
		input_free_device(dev);
		goto err_register_input_dev;
	}

	ret = sensors_create_symlink(&dev->dev.kobj, dev->name);
	if (ret < 0)
		goto err_create_sensor_symlink;

	/* sysfs node creation */
	ret = sysfs_create_group(&dev->dev.kobj,
				&icm42605m_smd_attribute_group);
	if (ret < 0)
		goto err_create_sysfs_group;

	cdata->smd_input = dev;

	return 0;

err_create_sysfs_group:
	sensors_remove_symlink(&dev->dev.kobj, dev->name);
err_create_sensor_symlink:
	input_unregister_device(dev);
err_register_input_dev:
	dev = NULL;
	return ret;
}

static int icm42605m_tilt_input_init(struct icm42605m_data *cdata)
{
	int ret = 0;
	struct input_dev *dev;

	dev = input_allocate_device();
	if (!dev)
		return -ENOMEM;

	dev->name = MODULE_NAME_TILT;
	dev->id.bustype = BUS_I2C;

	input_set_capability(dev, EV_REL, REL_MISC);
	input_set_drvdata(dev, cdata);

	ret = input_register_device(dev);
	if (ret < 0) {
		input_free_device(dev);
		goto err_register_input_dev;
	}

	ret = sensors_create_symlink(&dev->dev.kobj, dev->name);
	if (ret < 0)
		goto err_create_sensor_symlink;

	/* sysfs node creation */
	ret = sysfs_create_group(&dev->dev.kobj,
				&icm42605m_tilt_attribute_group);
	if (ret < 0)
		goto err_create_sysfs_group;

	cdata->tilt_input = dev;

	return 0;

err_create_sysfs_group:
	sensors_remove_symlink(&dev->dev.kobj, dev->name);
err_create_sensor_symlink:
	input_unregister_device(dev);
err_register_input_dev:
	dev = NULL;
	return ret;
}


static int icm42605m_vdd_onoff(struct icm42605m_data *cdata, int onoff)
{
	/* ldo control */
	if (cdata->icm42605m_ldo_pin) {
		gpio_set_value(cdata->icm42605m_ldo_pin, onoff);
		if (onoff)
			msleep(20);
		return 0;
	}

	return 0;
}

static int icm42605m_parse_dt(struct icm42605m_data *cdata)
{
	struct device_node *np;
	enum of_gpio_flags flags;
	int ret = 0;

	np = cdata->dev->of_node;
	if (!np)
		return -EINVAL;

	cdata->icm42605m_ldo_pin = of_get_named_gpio_flags(np,
				"st,vdd_ldo_pin", 0, &flags);
	if (cdata->icm42605m_ldo_pin < 0) {
		SENSOR_INFO("Cannot set vdd_ldo_pin through DTSI\n\n");
		cdata->icm42605m_ldo_pin = 0;
	} else {
		ret = gpio_request(cdata->icm42605m_ldo_pin, "st,vdd_ldo_pin");
		if (ret < 0)
			SENSOR_ERR("gpio %d request failed %d\n",
				cdata->icm42605m_ldo_pin, ret);
		else
			gpio_direction_output(cdata->icm42605m_ldo_pin, 0);
	}

	{
		struct pinctrl* p = pinctrl_get_select_default(cdata->dev);
		struct pinctrl_state* spi_active_state;

		spi_active_state = pinctrl_lookup_state(p, "pins_on");
		if(IS_ERR(spi_active_state)) {
			SENSOR_ERR("could not get pins idle state\n");
		} else {
			int status = pinctrl_select_state(p, spi_active_state);
			SENSOR_INFO("Get pins idle state\n");
			if(status)
				SENSOR_ERR("failed pinctrl select state idle state %d\n", status);
			else
				SENSOR_INFO("Get pinctrl select state idle state %d\n");
		}
	}

    if (of_property_read_u32(np, "position",
                            &cdata->position) < 0) {
            SENSOR_ERR("get position %d error\n", cdata->position);
            cdata->position = 0;
            return -ENODEV;
    }

	cdata->irq_gpio = of_get_named_gpio_flags(np, "tdk,irq-gpio", 0, &flags);
	if (cdata->irq_gpio < 0) {
		SENSOR_ERR("get irq_gpio = %d error\n", cdata->irq_gpio);
		return -ENODEV;
	}
	cdata->irq = gpio_to_irq(cdata->irq_gpio);
	return 0;
}

int icm42605m_dump_register_data_notify(struct notifier_block *nb,
	unsigned long val, void *v)
{
	struct icm42605m_data *cdata = container_of(nb, struct icm42605m_data, dump_nb);

	if(val == 1) {
		icm42605m_read_register(cdata);
	}
	return 0;
}

int inv_icm426xx_load_dmp_sram_code(struct icm42605m_data *cdata, const uint8_t *dmp_prog, const uint32_t start_offset, const uint32_t size)
{
	uint8_t pwr_mgmt;
	uint32_t i, cur_idx;
	uint8_t dmp_sram_offset = 0x40, data, data2;
	int status = 0;

	/* DMP SRAM is updated by DMP DMA every time accel ODR triggers, hence
	 * first 7B of SRAM are not usable.
	 * Since start addresses are aligned on 32B binary, there is some loss
	 * here (minor however).
	 */
	if (size + start_offset > 1024U)
		return INV_ERROR_SIZE;

	status |= cdata->tf->read(cdata, MPUREG_PWR_MGMT_0, 1, &pwr_mgmt, true);
	/* Writing DMP SRAM not supported when accel is not IDLE */
	if (pwr_mgmt & BIT_PWR_MGMT_0_ACCEL_MODE_MASK)
		return INV_ERROR;

	data = (pwr_mgmt | ((uint8_t)ICM426XX_PWR_MGMT_0_IDLE_DIS));
	status |= cdata->tf->write(cdata, MPUREG_PWR_MGMT_0, 1, &data, true);
	usleep_range(200,200);

	status |= inv_icm426xx_reset_dmp(cdata);

	data = BIT_DMP_MEM_ACCESS_EN;
	status |= cdata->tf->write(cdata, MPUREG_SCAN0, 1, &data, true);
	usleep_range(100,100);

	/* Write new DMP program into SRAM */
	data = dmp_sram_offset;
	status |= cdata->tf->write(cdata, MPUREG_MEM_BANK_SEL, 1, &data, true);
	cur_idx = 0;
	for (i = start_offset; i < (size + start_offset); i++) {
		if (0 == (i % 256)) {
			/* Start filling new DMP SRAM bank */
			data = dmp_sram_offset + (i / 256);
			status |= cdata->tf->write(cdata, MPUREG_MEM_BANK_SEL, 1, &data, true);
		}

		data = i % 256;
		status |= cdata->tf->write(cdata, MPUREG_MEM_START_ADDR, 1, &data, true);
		data = dmp_prog[cur_idx];
		status |= cdata->tf->write(cdata, MPUREG_MEM_R_W, 1, &data, true);
		cur_idx++;
	}

	if (cur_idx != size) {
		status = INV_ERROR_UNEXPECTED;
		goto end_load_dmp_sram;
	}

	/* Verify SRAM content is matching loaded DMP program */
	cur_idx = 0;
	i = start_offset;
	data = dmp_sram_offset;
	status |= cdata->tf->write(cdata, MPUREG_MEM_BANK_SEL, 1, &data, true);
	/* Program entry MEM_START_ADDR */
	data2 = i % 256;
	status |= cdata->tf->write(cdata, MPUREG_MEM_START_ADDR, 1, &data2, true);
	while (i < (size + start_offset)) {
		/* Handle MEM_BANK_SEL switch on 256 multiples */
		if (0 == (i % 256)) {
			data = dmp_sram_offset + (i / 256);
			status |= cdata->tf->write(cdata, MPUREG_MEM_BANK_SEL, 1, &data, true);
		}
		/* Read bytes [0-255] of each bank which was written */
		data = i % 256;
		if (0 == (data % 256)) {
			status |= cdata->tf->write(cdata, MPUREG_MEM_START_ADDR, 1, &data, true);
			status |= cdata->tf->read(cdata, MPUREG_MEM_START_ADDR, 1, &data2, true);
		}
		status |= cdata->tf->read(cdata, MPUREG_MEM_R_W, 1, &data, true);
		/* Check SRAM content match byte-to-byte */
		if (data != dmp_prog[cur_idx]) {
			status = INV_ERROR_MEM;
			goto end_load_dmp_sram;
		}

		i++;
		cur_idx++;
	}

	data = 0;
	status |= cdata->tf->write(cdata, MPUREG_SCAN0, 1, &data, true);
	usleep_range(100,100);
	if (!status) {
		// Succesful SRAM load, execution is possible
		cdata->dmp_from_sram = 1;
	}

	/* Update DMP program counter to start from SRAM */
	data = 3;
	status |= cdata->tf->write(cdata, MPUREG_REG_BANK_SEL, 1, &data, true);
	data = 0x8;
	status |= cdata->tf->write(cdata, 0x71, 1, &data, true);
	data = 0;
	status |= cdata->tf->write(cdata, MPUREG_REG_BANK_SEL, 1, &data, true);

end_load_dmp_sram:
	status |= cdata->tf->write(cdata, MPUREG_PWR_MGMT_0, 1, &pwr_mgmt, true);

	return status;
}

int icm42605m_common_probe(struct icm42605m_data *cdata, int irq, u16 bustype)
{
	int ret = 0;
    int err = 0;
	u8 val, otp_status;
	u8 intf_cfg4_reg;
    inv_icm426xx_apex_parameters_t apex_inputs;
	inv_icm426xx_interrupt_parameter_t config_int = {INV_ICM426XX_DISABLE,};
	int timeout = 1000; /* 1s */
	uint8_t retry = ICM_DMP_DOWNLOAD_RETRY;

 	SENSOR_INFO("Start!\n");

	dev_set_drvdata(cdata->dev, cdata);

	mutex_init(&cdata->bank_registers_lock);
	mutex_init(&cdata->tb.buf_lock);
	mutex_init(&cdata->mutex_enable);
	mutex_init(&cdata->mutex_read);

	err = icm42605m_parse_dt(cdata);
	if (err < 0)
		goto exit;

	/* turn on vdd */
	icm42605m_vdd_onoff(cdata, 1);


	/* verify whoami */
	ret = cdata->tf->read(cdata, MPUREG_WHO_AM_I, 1, &val, true);
	//if (ret)
	//	goto exit;
	SENSOR_INFO("whoami= %x\n", val);
	if (val != ICM42605_WHOAMI) {
		SENSOR_ERR("ERROR : bad WHOAMI value. Got 0x%02x (expected: 0x%02x)", val, ICM42605_WHOAMI);
		goto exit;
	}

	/* configure_serial_interface */
	val = 1;
	ret |= cdata->tf->write(cdata, MPUREG_REG_BANK_SEL, 1, &val, true);
	intf_cfg4_reg = ICM426XX_INTF_CONFIG4_AP_SPI4W;
	ret |= cdata->tf->write(cdata, MPUREG_INTF_CONFIG4_B1, 1, &intf_cfg4_reg, true);
	val = 0;
	ret |= cdata->tf->write(cdata, MPUREG_REG_BANK_SEL, 1, &val, true);

	/* soft reset device */
	val = ICM426XX_CHIP_CONFIG_RESET_EN;
	ret |= cdata->tf->write(cdata, MPUREG_CHIP_CONFIG, 1, &val, true);
	//if(ret)
	//	return ret;
	usleep_range(1000,1000);

	do {
		val = 1;
		ret |= cdata->tf->write(cdata, MPUREG_REG_BANK_SEL, 1, &val, true);
		ret |= cdata->tf->write(cdata, MPUREG_INTF_CONFIG4_B1, 1, &intf_cfg4_reg, true);
		ret |= cdata->tf->read(cdata, MPUREG_OTP_SEC_STATUS_B1, 1, &otp_status, true);
		val = 0;
		ret |= cdata->tf->write(cdata, MPUREG_REG_BANK_SEL, 1, &val, true);
		otp_status &= BIT_OTP_SEC_STATUS_OTP_DONE;
		//if(ret)
		//	return ret;
        usleep_range(1000,1000);
		timeout -= 1;
		if(timeout < 0){
            SENSOR_ERR("Timeout!");
            goto exit; /* timeout */
		}

	} while (otp_status != BIT_OTP_SEC_STATUS_OTP_DONE);

	/* Clear the Int Reset Done bit */
	ret |= cdata->tf->read(cdata, MPUREG_INT_STATUS, 1, &val, true);
	if (0 == (val & BIT_INT_STATUS_RESET_DONE)) {
        SENSOR_ERR("Reset not Done!");
		goto exit; /* unexpected error */
	}
	do {
		ret |= inv_icm426xx_load_dmp_sram_code(cdata, dmp_image, 0, sizeof(dmp_image)/sizeof(dmp_image[0]));
		retry--;
	} while (retry != 0 && ret != INV_ERROR_SUCCESS);
	
	if (ret != INV_ERROR_SUCCESS) {
		SENSOR_ERR("!!! ERROR : failed to download DMP image. #3, %d, %d\n\r", retry, ICM_DMP_DOWNLOAD_RETRY - retry);
	}
	
	// If dmp firmware download fails, execute soft reset to execute in ROM area
	// instead of SRAM area
	if(!cdata->dmp_from_sram) {
		/* soft reset device */
		val = ICM426XX_CHIP_CONFIG_RESET_EN;
		ret |= cdata->tf->write(cdata, MPUREG_CHIP_CONFIG, 1, &val, true);
		usleep_range(20000, 20000);

		/* Clear the Int Reset Done bit */
		ret |= cdata->tf->read(cdata, MPUREG_INT_STATUS, 1, &val, true);
 
		if (0 == (val & BIT_INT_STATUS_RESET_DONE)) {
			SENSOR_ERR("ROM Reset not Done!\n\r");
			//return -1; /* unexpected error */
		}
	}

	/* Enable INT2 */
	val = 1;
	ret |= cdata->tf->write(cdata, MPUREG_REG_BANK_SEL, 1, &val, true);
	val = 0;
	ret |= cdata->tf->write(cdata, MPUREG_INTF_CONFIG5_B1, 1, &val, true);
	ret |= cdata->tf->write(cdata, MPUREG_REG_BANK_SEL, 1, &val, true);

	ret |= cdata->tf->read(cdata, MPUREG_INT_CONFIG, 1, &val, true);
	/* Enable push pull on INT1 to avoid moving in Test Mode after a soft reset */
	val |= (u8)ICM426XX_INT_CONFIG_INT1_DRIVE_CIRCUIT_PP
		| (u8)ICM426XX_INT_CONFIG_INT2_DRIVE_CIRCUIT_PP;
	/* Configure the INT1 interrupt pulse as active high */
	val |= (u8)ICM426XX_INT_CONFIG_INT1_POLARITY_HIGH
		| (u8)ICM426XX_INT_CONFIG_INT2_POLARITY_HIGH;
#ifdef FEATURE_LATCHEDMODE
	/* Configure the interrupt clear option as latched mode */
	val |= (u8)ICM426XX_INT_CONFIG_INT1_INT_MODE_LATCHED
	| (u8)ICM426XX_INT_CONFIG_INT2_INT_MODE_LATCHED;
#endif
	ret |= cdata->tf->write(cdata, MPUREG_INT_CONFIG, 1, &val, true);

	ret |= inv_icm426xx_set_config_int1(cdata, &config_int);
	ret |= inv_icm426xx_set_config_int2(cdata, &config_int);

	/* Set the UI filter order to 2 for both gyro and accel */
	ret |= cdata->tf->read(cdata, MPUREG_GYRO_CONFIG1, 1, &val, true);
	val &= (u8)~BIT_GYRO_CONFIG1_GYRO_UI_FILT_ORD_MASK;
	val |= (u8)ICM426XX_GYRO_CONFIG_GYRO_UI_FILT_ORD_2ND_ORDER;
	ret |= cdata->tf->write(cdata, MPUREG_GYRO_CONFIG1, 1, &val, true);
	ret |= cdata->tf->read(cdata, MPUREG_ACCEL_CONFIG1, 1, &val, true);
	val &= (u8)~BIT_ACCEL_CONFIG1_ACCEL_UI_FILT_ORD_MASK;
	val |= (u8)ICM426XX_ACCEL_CONFIG_ACCEL_UI_FILT_ORD_2ND_ORDER;
	ret |= cdata->tf->write(cdata, MPUREG_ACCEL_CONFIG1, 1, &val, true);

	/* Enable FIFO for gyro */
	ret |= inv_icm426xx_configure_fifo(cdata, INV_ICM426XX_FIFO_ENABLED);

	/* Set gyro and accel FSR, Filter and ODR */
	ret |= inv_icm426xx_set_accel_fsr(cdata, ICM_ACCEL_FSR);
	ret |= inv_icm426xx_set_accel_ln_bw(cdata, ICM_ACCEL_FILT_BW);
	ret |= inv_icm426xx_set_accel_frequency(cdata, ICM_ACCEL_FREQ);
    ret |= inv_icm426xx_set_gyro_fsr(cdata, ICM_GYRO_FSR);
    ret |= inv_icm426xx_set_gyro_ln_bw(cdata, ICM_GYRO_FILT_BW);
	ret |= inv_icm426xx_set_gyro_frequency(cdata, ICM426XX_GYRO_CONFIG0_ODR_200_HZ);

	/* Configure the programmable parameter for number of accelerometer samples to wait before triggering tilt event */
	apex_inputs.tilt_wait_time = ICM_TILT_WAIT_TIME;
	/* Configure the programmable parameter for power mode disabled */
	apex_inputs.power_save = ICM426XX_APEX_CONFIG0_DMP_POWER_SAVE_DIS;
	/* Initializes APEX features */
	ret |= inv_icm426xx_configure_apex_parameters(cdata, &apex_inputs);

	ret |= inv_icm426xx_set_apex_frequency(cdata, ICM_TILT_FREQUENCY_MODE);
    SENSOR_INFO("PROBE : %d", ret);
	if (ret != INV_ERROR_SUCCESS) {
		SENSOR_ERR("!!! ERROR : failed to init.");
		goto exit;
	}

	/* input device init */
	err = icm42605m_acc_input_init(cdata);
	if (err < 0)
		goto exit_acc_input_init;

	err = icm42605m_gyro_input_init(cdata);
	if (err < 0)
		goto exit_gyro_input_init;

	err = icm42605m_smd_input_init(cdata);
	if (err < 0)
		goto exit_smd_input_init;

	err = icm42605m_tilt_input_init(cdata);
	if (err < 0)
		goto exit_tilt_input_init;

	/* factory test sysfs node */
	err = sensors_register(&cdata->acc_factory_dev, cdata,
		acc_sensor_attrs, MODULE_NAME_ACC);
	if (err < 0) {
		SENSOR_ERR("failed to sensors_register = %d\n", err);
		goto exit_acc_sensor_register_failed;
	}

	err = sensors_register(&cdata->gyro_factory_dev, cdata,
		gyro_sensor_attrs, MODULE_NAME_GYRO);
	if (err < 0) {
		SENSOR_ERR("failed to sensors_register = %d\n", err);
		goto exit_gyro_sensor_register_failed;
	}

	err = sensors_register(&cdata->smd_factory_dev, cdata,
		smd_sensor_attrs, MODULE_NAME_SMD);
	if (err) {
		SENSOR_ERR("failed to sensors_register = %d\n", err);
		goto exit_smd_sensor_register_failed;
	}

	err = sensors_register(&cdata->tilt_factory_dev, cdata,
		tilt_sensor_attrs, MODULE_NAME_TILT);
	if (err) {
		SENSOR_ERR("failed to sensors_register = %d\n", err);
		goto exit_tilt_sensor_register_failed;
	}

	/* workqueue init */
	hrtimer_init(&cdata->acc_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
	cdata->acc_delay = ns_to_ktime(ICM42605M_DELAY_DEFAULT);
	cdata->acc_timer.function = icm42605m_acc_timer_func;

	hrtimer_init(&cdata->gyro_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
	cdata->gyro_delay = ns_to_ktime(ICM42605M_DELAY_DEFAULT);
	cdata->gyro_timer.function = icm42605m_gyro_timer_func;

	/* the timer just fires off a work queue request.  we need a thread
	   to read the i2c (can be slow and blocking). */
	cdata->accel_wq = create_singlethread_workqueue("accel_wq");
	if (!cdata->accel_wq) {
		ret = -ENOMEM;
		SENSOR_ERR("could not create accel workqueue\n");
		goto exit_create_workqueue_acc;
	}

	cdata->gyro_wq = create_singlethread_workqueue("gyro_wq");
	if (!cdata->gyro_wq) {
		ret = -ENOMEM;
		SENSOR_ERR("could not create gyro workqueue\n");
		goto exit_create_workqueue_gyro;
	}

	/* this is the thread function we run on the work queue */
	INIT_WORK(&cdata->acc_work, icm42605m_acc_work_func);
	INIT_WORK(&cdata->gyro_work, icm42605m_gyro_work_func);

	atomic_set(&cdata->acc_wkqueue_en, 0);
	atomic_set(&cdata->gyro_wkqueue_en, 0);

	cdata->irq_wq = create_workqueue(cdata->name);
	if (!cdata->irq_wq) {
		ret = -ENOMEM;
		SENSOR_ERR("could not create irq workqueue\n");
		goto exit_create_workqueue_irq;
	}

	if (cdata->irq > 0) {
		wake_lock_init(&cdata->sa_wake_lock, WAKE_LOCK_SUSPEND,
		       ICM42605M_DEV_NAME "_sa_wake_lock");

		INIT_WORK(&cdata->data_work, icm42605m_irq_management);
		INIT_DELAYED_WORK(&cdata->sa_irq_work, icm42605m_sa_irq_work);

		ret = request_threaded_irq(cdata->irq, icm42605m_threaded, NULL,
				IRQF_TRIGGER_RISING, cdata->name, cdata);
		disable_irq(cdata->irq);

		SENSOR_INFO("Interrupt thread irq init, irq = %d\n", cdata->irq);
	}

	SENSOR_INFO("Done!\n");
	return 0;

exit_create_workqueue_irq:
#ifdef CONFIG_SENSORS_LSM6DSL_SUPPORT_VDIS
	kthread_stop(cdata->gyro_task);
	cdata->gyro_task = NULL;
#else
	destroy_workqueue(cdata->gyro_wq);
#endif
exit_create_workqueue_gyro:
	destroy_workqueue(cdata->accel_wq);
exit_create_workqueue_acc:
	sensors_unregister(cdata->tilt_factory_dev, tilt_sensor_attrs);
exit_tilt_sensor_register_failed:
	sensors_unregister(cdata->smd_factory_dev, smd_sensor_attrs);
exit_smd_sensor_register_failed:
	sensors_unregister(cdata->gyro_factory_dev, gyro_sensor_attrs);
exit_gyro_sensor_register_failed:
	sensors_unregister(cdata->acc_factory_dev, acc_sensor_attrs);
exit_acc_sensor_register_failed:
	sensors_remove_symlink(&cdata->tilt_input->dev.kobj,
					cdata->tilt_input->name);
	sysfs_remove_group(&cdata->tilt_input->dev.kobj,
					&icm42605m_tilt_attribute_group);
	input_unregister_device(cdata->tilt_input);
exit_tilt_input_init:
	sensors_remove_symlink(&cdata->smd_input->dev.kobj,
					cdata->smd_input->name);
	sysfs_remove_group(&cdata->smd_input->dev.kobj,
					&icm42605m_smd_attribute_group);
	input_unregister_device(cdata->smd_input);
exit_smd_input_init:
	sensors_remove_symlink(&cdata->gyro_input->dev.kobj,
					cdata->gyro_input->name);
	sysfs_remove_group(&cdata->gyro_input->dev.kobj,
					&icm42605m_gyro_attribute_group);
	input_unregister_device(cdata->gyro_input);
exit_gyro_input_init:
	sensors_remove_symlink(&cdata->acc_input->dev.kobj,
					cdata->acc_input->name);
	sysfs_remove_group(&cdata->acc_input->dev.kobj,
					&icm42605m_accel_attribute_group);
	input_unregister_device(cdata->acc_input);
exit_acc_input_init:
	if (cdata->icm42605m_ldo_pin)
		gpio_free(cdata->icm42605m_ldo_pin);
exit:
	mutex_destroy(&cdata->bank_registers_lock);
	mutex_destroy(&cdata->tb.buf_lock);
	mutex_destroy(&cdata->mutex_enable);
	mutex_destroy(&cdata->mutex_read);
    return err;
}
EXPORT_SYMBOL(icm42605m_common_probe);

int icm42605m_common_suspend(struct icm42605m_data *cdata)
{
	SENSOR_INFO("\n");
	if (atomic_read(&cdata->acc_wkqueue_en) == 1)
		icm42605m_disable_sensors(cdata, ICM42605M_ACCEL);
	if (atomic_read(&cdata->gyro_wkqueue_en) == 1)
		icm42605m_disable_sensors(cdata, ICM42605M_GYRO);

	return 0;
}
EXPORT_SYMBOL(icm42605m_common_suspend);

int icm42605m_common_resume(struct icm42605m_data *cdata)
{
	SENSOR_INFO("\n");

	if (atomic_read(&cdata->acc_wkqueue_en) == 1)
		icm42605m_enable_sensors(cdata, ICM42605M_ACCEL);
	if (atomic_read(&cdata->gyro_wkqueue_en) == 1)
		icm42605m_enable_sensors(cdata, ICM42605M_GYRO);

	return 0;
}
EXPORT_SYMBOL(icm42605m_common_resume);

void icm42605m_common_remove(struct icm42605m_data *cdata)
{
	if (cdata->enabled & (1 << ICM42605M_ACCEL))
		icm42605m_disable_sensors(cdata, ICM42605M_ACCEL);
	if (cdata->enabled & (1 << ICM42605M_GYRO))
		icm42605m_disable_sensors(cdata, ICM42605M_GYRO);

}
EXPORT_SYMBOL(icm42605m_common_remove);

void icm42605m_common_shutdown(struct icm42605m_data *cdata)
{
	u8 i;

	for (i = 0; i < ICM42605M_SENSORS_NUMB; i++)
		icm42605m_disable_sensors(cdata, i);

}
EXPORT_SYMBOL(icm42605m_common_shutdown);


MODULE_DESCRIPTION("TDK icm42605m driver");
MODULE_AUTHOR("Samsung");
MODULE_LICENSE("GPL v2");
